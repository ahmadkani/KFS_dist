{"version":3,"file":"kfs.js","sources":["/Users/ahmad/Documents/Development/kfs_build/kfs-vite/src/libs/MagicPortalES6.js","/Users/ahmad/Documents/Development/kfs_build/kfs-vite/src/WorkerPool.js","/Users/ahmad/Documents/Development/kfs_build/kfs-vite/src/memoryFs.js","/Users/ahmad/Documents/Development/kfs_build/kfs-vite/src/IDBFs.js","/Users/ahmad/Documents/Development/kfs_build/kfs-vite/src/libs/vfsUtils/gitAuth.js","/Users/ahmad/Documents/Development/kfs_build/kfs-vite/src/libs/vfsUtils/VFSUtils.js","/Users/ahmad/Documents/Development/kfs_build/kfs-vite/src/libs/vfsUtils/storageUtils.js","/Users/ahmad/Documents/Development/kfs_build/kfs-vite/src/libs/vfsUtils/supportChecker.js","/Users/ahmad/Documents/Development/kfs_build/kfs-vite/src/vfs.js","/Users/ahmad/Documents/Development/kfs_build/kfs-vite/src/libs/kfsUtils/versioningManager.js","/Users/ahmad/Documents/Development/kfs_build/kfs-vite/src/libs/kfsUtils/mergingManager.js","/Users/ahmad/Documents/Development/kfs_build/kfs-vite/src/kfs.js"],"sourcesContent":["var e=function(e){var t=this;this.rpc_counter=0,this.channel=e,this.foreign=new Map,this.local=new Map,this.calls=new Map,this.queue=[],this.connectionEstablished=!1,this.channel.addEventListener(\"message\",function(e){var n=e.data;if(n&&\"object\"==typeof n)switch(n.type){case\"MP_INIT\":return t.onInit(n);case\"MP_SET\":return t.onSet(n);case\"MP_CALL\":return t.onCall(n);case\"MP_RETURN\":return t.onReturn(n)}}),this.channel.postMessage({type:\"MP_INIT\",id:1,reply:!0})};e.prototype.onInit=function(e){this.connectionEstablished=!0;var t=this.queue;this.queue=[];for(var n=0,o=t;n<o.length;n+=1){this.channel.postMessage(o[n])}e.reply&&this.channel.postMessage({type:\"MP_INIT\",reply:!1})},e.prototype.onSet=function(e){for(var t=this,n={},o=e.object,s=function(){var s=i[r],c=!e.void.includes(s);n[s]=function(){for(var e=[],n=arguments.length;n--;)e[n]=arguments[n];return t.rpc_counter=(t.rpc_counter+1)%Number.MAX_SAFE_INTEGER,new Promise(function(n,r){t.postMessage({type:\"MP_CALL\",object:o,method:s,id:t.rpc_counter,args:e,reply:c}),c?t.calls.set(t.rpc_counter,{resolve:n,reject:r}):n()})}},r=0,i=e.methods;r<i.length;r+=1)s();var c=this.foreign.get(e.object);this.foreign.set(e.object,n),\"function\"==typeof c&&c(n)},e.prototype.onCall=function(e){var t=this,n=this.local.get(e.object);n&&n[e.method].apply(n,e.args).then(function(n){return e.reply&&t.channel.postMessage({type:\"MP_RETURN\",id:e.id,result:n})}).catch(function(n){return t.channel.postMessage({type:\"MP_RETURN\",id:e.id,error:n.message})})},e.prototype.onReturn=function(e){if(this.calls.has(e.id)){var t=this.calls.get(e.id),n=t.resolve,o=t.reject;this.calls.clear(e.id),e.error?o(e.error):n(e.result)}},e.prototype.postMessage=function(e){this.connectionEstablished?this.channel.postMessage(e):this.queue.push(e)},e.prototype.set=function(e,t,n){void 0===n&&(n={}),this.local.set(e,t);var o=Object.entries(t).filter(function(e){return\"function\"==typeof e[1]}).map(function(e){return e[0]});this.postMessage({type:\"MP_SET\",object:e,methods:o,void:n.void||[]})},e.prototype.get=function(e){return new Promise(function(t,n){var o=this;return this.foreign.has(e)?t(this.foreign.get(e)):t(new Promise(function(t,n){return o.foreign.set(e,t)}))}.bind(this))};export default function(t){var n=new e(t);Object.defineProperties(this,{get:{writable:!1,configurable:!1,value:n.get.bind(n)},set:{writable:!1,configurable:!1,value:n.set.bind(n)}})}\n//# sourceMappingURL=MagicPortalES6.js.map","import { Logger } from \"./libs/LoggerES6.js\";\nimport MagicPortal from \"./libs/MagicPortalES6.js\";\nimport { config } from './configES6.js';\nimport GitWorker from './workers/gitWorker.js?worker';\n\nconst logger = new Logger(config.logging.WorkerPool);\n\nfunction consoleDotLog(...parameters) {\n  logger.consoleDotLog('[WorkerPool]', ...parameters);\n}\n\nfunction consoleDotError(...parameters) {\n  logger.consoleDotError('[WorkerPool]', ...parameters);\n}\n\nconsoleDotLog('Loading workerPool.');\n\nclass WorkerPool {\n  constructor(workerClass = null) {\n    this.workers = new Map();\n    this.workerCount = 0;\n    // Allow dependency injection for testing\n    this.WorkerClass = workerClass || (typeof Worker !== 'undefined' ? Worker : null);\n  }\n\n  async getWorker(mountPath, useSW = false) {\n    try {\n      if (!this.WorkerClass) {\n        throw new Error(\"Worker class not available in this environment\");\n      }\n  \n      if (!this.workers.has(mountPath)) {\n        consoleDotLog(`Creating new worker for ${mountPath}`);\n\n        const worker = new GitWorker();\n\n  \n        // Add error handling\n        worker.onerror = (e) => {\n          consoleDotError('Worker error:', e);\n          consoleDotError('Error details:', {\n            filename: e.filename,\n            lineno: e.lineno,\n            colno: e.colno,\n            message: e.message\n          });\n          throw e;\n        };\n  \n        const portal = new MagicPortal(worker);\n        \n        // Add timeout for safety\n        const thread = await Promise.race([\n          portal.get(\"workerThread\"),\n          new Promise((_, reject) => \n            setTimeout(() => reject(new Error('Worker thread timeout')), 5000)\n          )\n        ]);\n        \n        consoleDotLog('Worker thread obtained, waiting for readiness...');\n        await thread.ready();\n        consoleDotLog('Worker is ready');\n  \n        const swSupport = typeof navigator !== 'undefined' && 'serviceWorker' in navigator;\n        await thread.execute('setSWUsage', { supportsServiceWorker: swSupport, useSW });\n  \n        this.workers.set(mountPath, {\n          worker,\n          portal,\n          thread,\n          users: 0\n        });\n        \n        this.workerCount++;\n        consoleDotLog(`Worker for ${mountPath} initialized`);\n      }\n  \n      const entry = this.workers.get(mountPath);\n      entry.users++;\n      return entry;\n    } catch (error) {\n      consoleDotError(`Failed to get worker for ${mountPath}:`, error);\n      throw error;\n    }\n  }\n\n  async releaseWorker(mountPath) {\n    if (this.workers.has(mountPath)) {\n      const entry = this.workers.get(mountPath);\n      entry.users--;\n      \n      if (entry.users <= 0) {\n        entry.worker.terminate();\n        this.workers.delete(mountPath);\n        this.workerCount--;\n        consoleDotLog(`Terminated worker for ${mountPath}`);\n      }\n    }\n  }\n\n  async forceTerminateAll() {\n    for (const [path, {worker}] of this.workers) {\n      worker.terminate();\n      consoleDotLog(`Force terminated worker for ${path}`);\n    }\n    this.workers.clear();\n    this.workerCount = 0;\n  }\n\n  getActiveCount() {\n    return this.workerCount;\n  }\n}\n\n// Singleton instance\nexport const workerPool = new WorkerPool();","import { workerPool } from \"./WorkerPool.js\";\nimport { Logger } from \"./libs/LoggerES6.js\";\nimport { config } from './configES6.js';\n\nconst logger = new Logger(config.logging.memoryFS);\n\nfunction consoleDotLog(...parameters) {\n  logger.consoleDotLog('[ MemoryFS ] ', ...parameters);\n}\n\nfunction consoleDotError(...parameters) {\n  logger.consoleDotError('[ MemoryFS ] ', ...parameters);\n}\n\nconsoleDotLog('memoryFs loaded.');\n\nclass MemoryFS {\n  constructor(fsName, options = {}) {\n    this.fsName = fsName;\n    this.fileDescriptors = new Map();\n    this.fdCounter = 3;\n    this.workerEntry = null;\n    this.workerThread = null;\n    this.useSW = options?.useSW || null;\n    this.versioningStrategy = options?.versioning?.strategy || config.versioning.strategy;\n    this.doImmediateCommit = (this.versioningStrategy === 'immediate') ? true : false;\n    consoleDotLog(`MemoryFS created for ${fsName}`);\n  }\n\n  async initializeWorker() {\n    this.workerEntry = await workerPool.getWorker(this.fsName, this.useSW);\n    this.workerThread = this.workerEntry.thread;\n\n    await this.workerThread.execute('setFs', {\n      fsName: this.fsName,\n      fsType: 'memory',\n    });\n\n    consoleDotLog(`Worker initialized for ${this.fsName}`);\n  }\n\n  async cleanup() {\n    if (this.workerEntry) {\n      await workerPool.releaseWorker(this.fsName);\n      this.workerEntry = null;\n      this.workerThread = null;\n    }\n  }\n\n  async fs_fopen(filename, mode) {\n    if (!this.workerThread) await this.initializeWorker();\n    \n    // Check if parent directory exists for new files\n    if (mode.includes('w') || mode.includes('a') || mode.includes('x')) {\n      const parentDir = filename.split('/').slice(0, -1).join('/');\n      if (parentDir) {\n        const dirExists = await this.workerThread.execute('isDirectoryDot', { path: parentDir });\n        if (!dirExists.exists || !dirExists.isDirectory) {\n          throw new Error(`ENOENT: no such directory, open '${filename}'`);\n        }\n      }\n    }\n\n    const fd = this.fdCounter++;\n    this.fileDescriptors.set(fd, { path: filename, pos: 0, mode });\n    consoleDotLog(`File descriptor ${fd} created for ${filename}`);\n    return fd;\n  }\n\n  async fs_fclose(fd) {\n    consoleDotLog(`Closing file descriptor: ${fd}`);\n    if (!this.fileDescriptors.has(fd)) {\n      throw new Error(`EBADF: bad file descriptor, close '${fd}'`);\n    }\n    this.fileDescriptors.delete(fd);\n    consoleDotLog(`File descriptor ${fd} closed successfully.`);\n    return 0;\n  }\n\n  async fs_fread(fd, length) {\n    consoleDotLog(`Reading ${length} bytes from file descriptor: ${fd}`);\n    const file = this.fileDescriptors.get(fd);\n    if (!file) {\n      throw new Error(`EBADF: bad file descriptor, read '${fd}'`);\n    }\n\n    try {\n      if (!this.workerThread) await this.initializeWorker();\n      const data = await this.workerThread.execute('readFileDot', { filePath: file.path });\n      if (data === null) {\n        throw new Error(`ENOENT: no such file, read '${file.path}'`);\n      }\n      const chunk = data.slice(file.pos, file.pos + length);\n      file.pos += chunk.length;\n      consoleDotLog(`Read chunk: ${chunk}, new position: ${file.pos}`);\n      return chunk;\n    } catch (error) {\n      consoleDotError(`Error reading file ${file.path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_fwrite(fd, content) {\n    consoleDotLog(`Writing content to file descriptor: ${fd}`);\n    const file = this.fileDescriptors.get(fd);\n    if (!file) {\n      throw new Error(`EBADF: bad file descriptor, write '${fd}'`);\n    }\n\n    try {\n      if (!this.workerThread) await this.initializeWorker();\n      \n      // Check if the file's parent directory exists\n      const parentDir = file.path.split('/').slice(0, -1).join('/');\n      if (parentDir) {\n        const dirExists = await this.workerThread.execute('isDirectoryDot', { path: parentDir });\n        if (!dirExists.exists || !dirExists.isDirectory) {\n          throw new Error(`ENOENT: no such directory, open '${file.path}'`);\n        }\n      }\n\n      let currentData = await this.workerThread.execute('readFileDot', { filePath: file.path }).catch(() => \"\");\n      let data = currentData;\n      consoleDotLog(`Current data in file ${file.path}:`, data);\n      if (data === null) data = \"\";\n      data = data.slice(0, file.pos) + content + data.slice(file.pos + content.length);\n      await this.workerThread.execute('writeFileDot', {\n        filePath: file.path,\n        fileContent: data,\n        doCommit: this.doImmediateCommit\n      });\n      file.pos += content.length;\n      consoleDotLog(`Content written to file ${file.path}, new position: ${file.pos}`);\n      return content.length;\n    } catch (error) {\n      consoleDotError(`Error writing to file ${file.path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_fseek(fd, offset, whence) {\n    consoleDotLog(`Seeking in file descriptor: ${fd}, offset: ${offset}, whence: ${whence}`);\n    const file = this.fileDescriptors.get(fd);\n    if (!file) {\n      throw new Error(`EBADF: bad file descriptor, seek '${fd}'`);\n    }\n\n    try {\n      if (!this.workerThread) await this.initializeWorker();\n      const data = await this.workerThread.execute('readFileDot', { filePath: file.path }).catch(() => \"\");\n      if (whence === \"SEEK_SET\") file.pos = offset;\n      else if (whence === \"SEEK_CUR\") file.pos += offset;\n      else if (whence === \"SEEK_END\") file.pos = data.length + offset;\n\n      file.pos = Math.max(0, Math.min(file.pos, data.length));\n      consoleDotLog(`New position in file ${file.path}: ${file.pos}`);\n      return 0;\n    } catch (error) {\n      consoleDotError(`Error seeking in file ${file.path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_ftell(fd) {\n    consoleDotLog(`Getting current position for file descriptor: ${fd}`);\n    const file = this.fileDescriptors.get(fd);\n    if (!file) {\n      throw new Error(`EBADF: bad file descriptor, tell '${fd}'`);\n    }\n    consoleDotLog(`Current position in file ${file.path}: ${file.pos}`);\n    return file.pos;\n  }\n\n  async fs_ftruncate(fd, length) {\n    consoleDotLog(`Truncating file descriptor: ${fd} to length: ${length}`);\n    const file = this.fileDescriptors.get(fd);\n    if (!file) {\n      throw new Error(`EBADF: bad file descriptor, truncate '${fd}'`);\n    }\n\n    try {\n      if (!this.workerThread) await this.initializeWorker();\n      let currentData = await this.workerThread.execute('readFileDot', { filePath: file.path }).catch(() => \"\");\n      let data = currentData;\n      consoleDotLog(`Current data in file ${file.path}:`, data);\n      data = data.slice(0, length);\n      await this.workerThread.execute('writeFileDot', {\n        filePath: file.path,\n        fileContent: data,\n        doCommit: this.doImmediateCommit\n      });\n      consoleDotLog(`File ${file.path} truncated to length: ${length}`);\n      return 0;\n    } catch (error) {\n      consoleDotError(`Error truncating file ${file.path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_stat(path) {\n    consoleDotLog(`Getting stats for path: ${path}`);\n  \n    try {\n      const normalizedPath = path.replace(/^\\/+|\\/+$/g, '');\n      normalizedPath.includes('.git')\n      if (!this.workerThread) await this.initializeWorker();\n  \n      // First check basic existence and directory status\n      const exists = await this.workerThread.execute('isDirectoryDot', { path });\n      if (!exists.exists) {\n        throw new Error(`ENOENT: no such file or directory, stat '${path}'`);\n      }\n  \n      // Get the complete note metadata\n      const noteType = exists.isDirectory ? 'dentry' : 'inode';\n      const noteData = await this.workerThread.execute('getPathNote', {\n        path\n      });\n\n      // If note doesn't exist, create basic stats\n      if (noteData?.error || !noteData || !noteData?.paths?.[normalizedPath]) {\n        consoleDotLog(`No note found for ${path}, returning basic stats`);\n      }\n  \n      // Process the full metadata\n      const metadata = noteData?.paths?.[normalizedPath]?.metadata || noteData;\n      const stats = {\n        // Standard fs.Stats properties\n        dev: 0,\n        inode: metadata.inode || metadata.dentry_id || 0,\n        mode: parseInt(metadata.mode, 8) || (exists?.isDirectory ? 16877 : 33188),\n        nlink: 1,\n        uid: metadata.uid || 1000,\n        gid: metadata.gid || 1000,\n        rdev: 0,\n        size: metadata.size || 0,\n        blksize: metadata.block_size || 4096,\n        blocks: Math.ceil((metadata.size || 0) / 4096),\n        atimeMs: new Date(metadata.atime || metadata.updated_at).getTime(),\n        mtimeMs: new Date(metadata.mtime || metadata.updated_at).getTime(),\n        ctimeMs: new Date(metadata.ctime || metadata.created_at).getTime(),\n        birthtimeMs: new Date(metadata.created_at).getTime(),\n  \n        // Extended properties from notes\n        acl: metadata.acl || 'root',\n        owner: metadata.owner,\n        fsType: metadata.fsType,\n        fullPath: metadata.full_path || path,\n  \n        // Boolean check methods\n        isDirectory: () => exists.isDirectory,\n        isFile: () => !exists.isDirectory,\n        isBlockDevice: () => false,\n        isCharacterDevice: () => false,\n        isSymbolicLink: () => false,\n        isFIFO: () => false,\n        isSocket: () => false,\n  \n        // Timestamp getters\n        atime: () => new Date(metadata.atime || metadata.updated_at),\n        mtime: () => new Date(metadata.mtime || metadata.updated_at),\n        ctime: () => new Date(metadata.ctime || metadata.created_at),\n        birthtime: () => new Date(metadata.created_at),\n  \n        // Additional metadata\n        getMetadata: () => metadata,\n        getNoteType: () => noteType,\n        getAllPaths: () => noteData.filepath_metadata ? Object.keys(noteData.filepath_metadata) : [path]\n      };\n  \n      consoleDotLog(`Retrieved detailed stats for ${path}`, stats);\n      return stats;\n    } catch (error) {\n      consoleDotError(`Error getting stats for path ${path}:`, error);\n      \n      // Return basic stats if detailed info fails\n      if (error.message.includes('ENOENT')) {\n        throw error;\n      }\n    }\n  }\n\n  async fs_fstat(fd) {\n    consoleDotLog(`Getting stats for file descriptor: ${fd}`);\n    const file = this.fileDescriptors.get(fd);\n    if (!file) {\n      throw new Error(`EBADF: bad file descriptor, fstat '${fd}'`);\n    }\n    return this.fs_stat(file.path);\n  }\n\n  async fs_remove(path) {\n    if (!this.workerThread) await this.initializeWorker();\n    consoleDotLog(`Removing file: ${path}`);\n    try {\n      const exists = await this.workerThread.execute('isDirectoryDot', { path });\n      if (!exists.exists) {\n        throw new Error(`ENOENT: no such file, unlink '${path}'`);\n      }\n      if (exists.isDirectory) {\n        throw new Error(`EISDIR: illegal operation on a directory, unlink '${path}'`);\n      }\n      \n      await this.workerThread.execute('removeFileDot', {\n        filePath: path,\n        doCommit: this.doImmediateCommit\n      });\n      return 0;\n    } catch (error) {\n      consoleDotError(`Error removing file ${path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_mkdir(path) {\n    if (!this.workerThread) await this.initializeWorker();\n    consoleDotLog(`Creating directory: ${path}`);\n    try {\n      // Check if parent directory exists\n      const parentDir = path.split('/').slice(0, -1).join('/');\n      if (parentDir) {\n        const dirExists = await this.workerThread.execute('isDirectoryDot', { path: parentDir });\n        if (!dirExists.exists || !dirExists.isDirectory) {\n          throw new Error(`ENOENT: no such directory, mkdir '${path}'`);\n        }\n      }\n\n      // Check if path already exists\n      const exists = await this.workerThread.execute('isDirectoryDot', { path });\n      if (exists.exists) {\n        if (exists.isDirectory) {\n          consoleDotError(`EEXIST: directory already exists, mkdir '${path}'`);\n          return -1;\n        } else {\n          throw new Error(`ENOTDIR: path exists but is not a directory, mkdir '${path}'`);\n        }\n      }\n\n      await this.workerThread.execute('mkdirDot', {\n        dirPath: path,\n        doCommit: this.doImmediateCommit\n      });\n      return 0;\n    } catch (error) {\n      consoleDotError(`Error creating directory ${path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_rmdir(path) {\n    if (!this.workerThread) await this.initializeWorker();\n    consoleDotLog(`Removing directory: ${path}`);\n    try {\n      const exists = await this.workerThread.execute('isDirectoryDot', { path });\n      if (!exists.exists) {\n        throw new Error(`ENOENT: no such directory, rmdir '${path}'`);\n      }\n      if (!exists.isDirectory) {\n        throw new Error(`ENOTDIR: not a directory, rmdir '${path}'`);\n      }\n\n      // Check if directory is empty\n      const dirContents = await this.fs_readdir(path);\n      if (dirContents.length > 0) {\n        throw new Error(`ENOTEMPTY: directory not empty, rmdir '${path}'`);\n      }\n\n      await this.workerThread.execute('removeDirDot', {\n        dirPath: path,\n        doCommit: this.doImmediateCommit\n      });\n      return 0;\n    } catch (error) {\n      consoleDotError(`Error removing directory ${path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_rename(oldPath, newPath) {\n    if (!this.workerThread) await this.initializeWorker();\n    consoleDotLog(`Renaming ${oldPath} to ${newPath}`);\n    try {\n      // Check if oldPath exists\n      const oldExists = await this.workerThread.execute('isDirectoryDot', { path: oldPath });\n      if (!oldExists.exists) {\n        throw new Error(`ENOENT: no such file or directory, rename '${oldPath}' -> '${newPath}'`);\n      }\n\n      // Check if newPath's parent directory exists\n      const newParentDir = newPath.split('/').slice(0, -1).join('/');\n      if (newParentDir) {\n        const parentExists = await this.workerThread.execute('isDirectoryDot', { path: newParentDir });\n        if (!parentExists.exists || !parentExists.isDirectory) {\n          throw new Error(`ENOENT: no such directory, rename '${oldPath}' -> '${newPath}'`);\n        }\n      }\n\n      await this.workerThread.execute('rename', {\n        oldPath,\n        newPath\n      });\n      return 0;\n    } catch (error) {\n      consoleDotError(`Error renaming ${oldPath} to ${newPath}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_opendir(path) {\n    if (!this.workerThread) await this.initializeWorker();\n    consoleDotLog(`Opening directory: ${path}`);\n    try {\n      const exists = await this.workerThread.execute('isDirectoryDot', { path });\n      if (!exists.exists) {\n        throw new Error(`ENOENT: no such directory, opendir '${path}'`);\n      }\n      if (!exists.isDirectory) {\n        throw new Error(`ENOTDIR: not a directory, opendir '${path}'`);\n      }\n\n      await this.workerThread.execute('opendir', { path });\n      return 0;\n    } catch (error) {\n      consoleDotError(`Error opening directory ${path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_readdir(path, options = {}) {\n    consoleDotLog(`Reading directory: ${path}`);\n    try {\n      if (!this.workerThread) await this.initializeWorker();\n\n      const exists = await this.workerThread.execute('isDirectoryDot', { path });\n      if (!exists.exists) {\n        throw new Error(`ENOENT: no such directory, readdir '${path}'`);\n      }\n      if (!exists.isDirectory) {\n        throw new Error(`ENOTDIR: not a directory, readdir '${path}'`);\n      }\n\n      const result = await this.workerThread.execute('readDirDot', { path });\n      const dirEntries = result?.entries || [];\n\n      return dirEntries.map(entry => ({ path: entry.path, type: (entry.type === 'tree' ? 'dir' : 'file') }));\n    } catch (error) {\n      consoleDotError(`Error reading directory ${path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_feof(fd) {\n    consoleDotLog(`Checking EOF for file descriptor: ${fd}`);\n    const file = this.fileDescriptors.get(fd);\n    if (!file) {\n      throw new Error(`EBADF: bad file descriptor, eof '${fd}'`);\n    }\n\n    try {\n      if (!this.workerThread) await this.initializeWorker();\n      const data = await this.workerThread.execute('readFileDot', { filePath: file.path }).catch(() => \"\");\n      consoleDotLog(`Current data in file ${file.path}:`, data);\n      const eof = file.pos >= data.length;\n      consoleDotLog(`EOF status for file ${file.path}: ${eof}`);\n      return eof;\n    } catch (error) {\n      consoleDotError(`Error checking EOF for file ${file.path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_fflush(fd) {\n    consoleDotLog(`Flushing file descriptor: ${fd}`);\n    return 0;\n  }\n\n  async fs_fcloseall() {\n    consoleDotLog(\"Closing all file descriptors.\");\n    this.fileDescriptors.clear();\n    return 0;\n  }\n}\n\nexport { MemoryFS };","import { Logger } from \"./libs/LoggerES6.js\";\nimport { workerPool } from \"./WorkerPool.js\";\nimport { config } from './configES6.js';\nimport LightningFS from '@isomorphic-git/lightning-fs';\n\nconst logger = new Logger(config.logging.IDBFs);\n\nfunction consoleDotLog(...parameters) {\n  logger.consoleDotLog('[IDBFS] ', ...parameters);\n}\n\nfunction consoleDotError(...parameters) {\n  logger.consoleDotError('[IDBFS] ', ...parameters);\n}\n\nclass IDBFs {\n  constructor(fsName, options = {}) {\n    this.fs = new LightningFS(fsName, options);\n    this.fileDescriptors = new Map();\n    this.fdCounter = 3;\n    this.workerEntry = null;\n    this.workerThread = null;\n    this.fsName = fsName;\n    this.useSW = options?.useSW || null;\n    this.versioningStrategy = options?.versioning?.strategy || config.versioning.strategy;\n    this.doImmediateCommit = (this.versioningStrategy === 'immediate') ? true : false;\n\n    // Initialize worker asynchronously\n    (async () => {\n      await this.initializeWorker();\n    })();\n\n    consoleDotLog(\"IDBFS initialized with LightningFS.\");\n  }\n\n  async initializeWorker() {\n    this.workerEntry = await workerPool.getWorker(this.fsName, this.useSW);\n    this.workerThread = this.workerEntry.thread;\n\n    await this.workerThread.execute('setFs', {\n      fsName: this.fsName,\n      fsType: 'idb',\n      gitDir: '/'\n    });\n\n    consoleDotLog(`Worker initialized for ${this.fsName}`);\n  }\n\n  async cleanup() {\n    if (this.workerEntry) {\n      await workerPool.releaseWorker(this.fsName);\n      this.workerEntry = null;\n      this.workerThread = null;\n    }\n  }\n\n  async fs_fopen(filename, mode) {\n    if (!this.workerThread) await this.initializeWorker();\n    consoleDotLog(`Opening file: ${filename} with mode: ${mode}`);\n    \n    // Check if parent directory exists for new files\n    if (mode.includes('w') || mode.includes('a') || mode.includes('x')) {\n      const parentDir = filename.split('/').slice(0, -1).join('/');\n      if (parentDir) {\n        const dirExists = await this.workerThread.execute('isDirectoryDot', { path: parentDir });\n        if (!dirExists.exists || !dirExists.isDirectory) {\n          throw new Error(`ENOENT: no such directory, open '${filename}'`);\n        }\n      }\n    }\n\n    const fd = this.fdCounter++;\n    this.fileDescriptors.set(fd, { path: filename, pos: 0, mode });\n    consoleDotLog(`File descriptor ${fd} created for file: ${filename}`);\n    return fd;\n  }\n\n  async fs_fclose(fd) {\n    consoleDotLog(`Closing file descriptor: ${fd}`);\n    if (!this.fileDescriptors.has(fd)) {\n      throw new Error(`EBADF: bad file descriptor, close '${fd}'`);\n    }\n    this.fileDescriptors.delete(fd);\n    consoleDotLog(`File descriptor ${fd} closed successfully.`);\n    return 0;\n  }\n\n  async fs_fread(fd, length) {\n    consoleDotLog(`Reading ${length} bytes from file descriptor: ${fd}`);\n    const file = this.fileDescriptors.get(fd);\n    if (!file) {\n      throw new Error(`EBADF: bad file descriptor, read '${fd}'`);\n    }\n\n    try {\n      if (!this.workerThread) await this.initializeWorker();\n      const data = await this.workerThread.execute('readFileDot', { filePath: file.path });\n      if (data === null) {\n        throw new Error(`ENOENT: no such file, read '${file.path}'`);\n      }\n      const chunk = data.slice(file.pos, file.pos + length);\n      file.pos += chunk.length;\n      consoleDotLog(`Read chunk: ${chunk}, new position: ${file.pos}`);\n      return chunk;\n    } catch (error) {\n      consoleDotError(`Error reading file ${file.path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_fwrite(fd, content) {\n    consoleDotLog(`Writing content to file descriptor: ${fd}`);\n    const file = this.fileDescriptors.get(fd);\n    if (!file) {\n      throw new Error(`EBADF: bad file descriptor, write '${fd}'`);\n    }\n\n    try {\n      if (!this.workerThread) await this.initializeWorker();\n      \n      // Check if the file's parent directory exists\n      const parentDir = file.path.split('/').slice(0, -1).join('/');\n      if (parentDir) {\n        const dirExists = await this.workerThread.execute('isDirectoryDot', { path: parentDir });\n        if (!dirExists.exists || !dirExists.isDirectory) {\n          throw new Error(`ENOENT: no such directory, open '${file.path}'`);\n        }\n      }\n\n      let currentData = await this.workerThread.execute('readFileDot', { filePath: file.path }).catch(() => \"\");\n      let data = currentData;\n      consoleDotLog(`Current data in file ${file.path}:`, data);\n      if (data === null) data = \"\";\n      data = data.slice(0, file.pos) + content + data.slice(file.pos + content.length);\n      await this.workerThread.execute('writeFileDot', {\n        filePath: file.path,\n        fileContent: data,\n        doCommit: this.doImmediateCommit\n      });\n      file.pos += content.length;\n      consoleDotLog(`Content written to file ${file.path}, new position: ${file.pos}`);\n      return content.length;\n    } catch (error) {\n      consoleDotError(`Error writing to file ${file.path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_fseek(fd, offset, whence) {\n    consoleDotLog(`Seeking in file descriptor: ${fd}, offset: ${offset}, whence: ${whence}`);\n    const file = this.fileDescriptors.get(fd);\n    if (!file) {\n      throw new Error(`EBADF: bad file descriptor, seek '${fd}'`);\n    }\n\n    try {\n      if (!this.workerThread) await this.initializeWorker();\n      const data = await this.workerThread.execute('readFileDot', { filePath: file.path }).catch(() => \"\");\n      if (whence === \"SEEK_SET\") file.pos = offset;\n      else if (whence === \"SEEK_CUR\") file.pos += offset;\n      else if (whence === \"SEEK_END\") file.pos = data.length + offset;\n\n      file.pos = Math.max(0, Math.min(file.pos, data.length));\n      consoleDotLog(`New position in file ${file.path}: ${file.pos}`);\n      return 0;\n    } catch (error) {\n      consoleDotError(`Error seeking in file ${file.path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_ftell(fd) {\n    consoleDotLog(`Getting current position for file descriptor: ${fd}`);\n    const file = this.fileDescriptors.get(fd);\n    if (!file) {\n      throw new Error(`EBADF: bad file descriptor, tell '${fd}'`);\n    }\n    consoleDotLog(`Current position in file ${file.path}: ${file.pos}`);\n    return file.pos;\n  }\n\n  async fs_ftruncate(fd, length) {\n    consoleDotLog(`Truncating file descriptor: ${fd} to length: ${length}`);\n    const file = this.fileDescriptors.get(fd);\n    if (!file) {\n      throw new Error(`EBADF: bad file descriptor, truncate '${fd}'`);\n    }\n\n    try {\n      if (!this.workerThread) await this.initializeWorker();\n      let currentData = await this.workerThread.execute('readFileDot', { filePath: file.path }).catch(() => \"\");\n      let data = currentData;\n      consoleDotLog(`Current data in file ${file.path}:`, data);\n      data = data.slice(0, length);\n      await this.workerThread.execute('writeFileDot', {\n        filePath: file.path,\n        fileContent: data,\n        doCommit: this.doImmediateCommit\n      });\n      consoleDotLog(`File ${file.path} truncated to length: ${length}`);\n      return 0;\n    } catch (error) {\n      consoleDotError(`Error truncating file ${file.path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_stat(path) {\n    consoleDotLog(`Getting stats for path: ${path}`);\n  \n    try {\n      const normalizedPath = path.replace(/^\\/+|\\/+$/g, '');\n      if (!this.workerThread) await this.initializeWorker();\n  \n      // First check basic existence and directory status\n      const exists = await this.workerThread.execute('isDirectoryDot', { path });\n      if (!exists.exists) {\n        throw new Error(`ENOENT: no such file or directory, stat '${path}'`);\n      }\n  \n      // Get the complete note metadata\n      const noteType = exists.isDirectory ? 'dentry' : 'inode';\n      const noteData = await this.workerThread.execute('getPathNote', {\n        path\n      });\n\n      // If note doesn't exist, create basic stats\n      if (noteData?.error || !noteData || !noteData?.paths?.[normalizedPath]) {\n        consoleDotLog(`No note found for ${path}, returning basic stats`);\n      }\n  \n      // Process the full metadata\n      const metadata = noteData?.paths?.[normalizedPath]?.metadata || noteData;\n      const stats = {\n        // Standard fs.Stats properties\n        dev: 0,\n        ino: metadata.inode || metadata.dentry_id || 0,\n        mode: parseInt(metadata.mode, 8) || (exists?.isDirectory ? 16877 : 33188),\n        nlink: 1,\n        uid: metadata.uid || 1000,\n        gid: metadata.gid || 1000,\n        rdev: 0,\n        size: metadata.size || 0,\n        blksize: metadata.block_size || 4096,\n        blocks: Math.ceil((metadata.size || 0) / 4096),\n        atimeMs: new Date(metadata.atime || metadata.updated_at).getTime(),\n        mtimeMs: new Date(metadata.mtime || metadata.updated_at).getTime(),\n        ctimeMs: new Date(metadata.ctime || metadata.created_at).getTime(),\n        birthtimeMs: new Date(metadata.created_at).getTime(),\n  \n        // Extended properties from notes\n        acl: metadata.acl || 'root',\n        owner: metadata.owner,\n        fsType: metadata.fsType,\n        fullPath: metadata.full_path || path,\n  \n        // Boolean check methods\n        isDirectory: () => exists.isDirectory,\n        isFile: () => !exists.isDirectory,\n        isBlockDevice: () => false,\n        isCharacterDevice: () => false,\n        isSymbolicLink: () => false,\n        isFIFO: () => false,\n        isSocket: () => false,\n  \n        // Timestamp getters\n        atime: () => new Date(metadata.atime || metadata.updated_at),\n        mtime: () => new Date(metadata.mtime || metadata.updated_at),\n        ctime: () => new Date(metadata.ctime || metadata.created_at),\n        birthtime: () => new Date(metadata.created_at),\n  \n        // Additional metadata\n        getMetadata: () => metadata,\n        getNoteType: () => noteType,\n        getAllPaths: () => noteData.filepath_metadata ? Object.keys(noteData.filepath_metadata) : [path]\n      };\n  \n      consoleDotLog(`Retrieved detailed stats for ${path}`, stats);\n      return stats;\n    } catch (error) {\n      consoleDotError(`Error getting stats for path ${path}:`, error);\n      \n      // Return basic stats if detailed info fails\n      if (error.message.includes('ENOENT')) {\n        throw error;\n      }\n    }\n  }\n\n  async fs_fstat(fd) {\n    consoleDotLog(`Getting stats for file descriptor: ${fd}`);\n    const file = this.fileDescriptors.get(fd);\n    if (!file) {\n      throw new Error(`EBADF: bad file descriptor, fstat '${fd}'`);\n    }\n    return this.fs_stat(file.path);\n  }\n\n  async fs_remove(path) {\n    if (!this.workerThread) await this.initializeWorker();\n    consoleDotLog(`Removing file: ${path}`);\n    try {\n      const exists = await this.workerThread.execute('isDirectoryDot', { path });\n      if (!exists.exists) {\n        throw new Error(`ENOENT: no such file, unlink '${path}'`);\n      }\n      if (exists.isDirectory) {\n        throw new Error(`EISDIR: illegal operation on a directory, unlink '${path}'`);\n      }\n      \n      await this.workerThread.execute('removeFileDot', {\n        filePath: path,\n        doCommit: this.doImmediateCommit\n      });\n      return 0;\n    } catch (error) {\n      consoleDotError(`Error removing file ${path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_mkdir(path) {\n    if (!this.workerThread) await this.initializeWorker();\n    consoleDotLog(`Creating directory: ${path}`);\n    try {\n      // Check if parent directory exists\n      const parentDir = path.split('/').slice(0, -1).join('/');\n      if (parentDir) {\n        const dirExists = await this.workerThread.execute('isDirectoryDot', { path: parentDir });\n        if (!dirExists.exists || !dirExists.isDirectory) {\n          throw new Error(`ENOENT: no such directory, mkdir '${path}'`);\n        }\n      }\n\n      // Check if path already exists\n      const exists = await this.workerThread.execute('isDirectoryDot', { path });\n      if (exists.exists) {\n        throw new Error(`EEXIST: file or directory already exists, mkdir '${path}'`);\n      }\n\n      await this.workerThread.execute('mkdirDot', {\n        dirPath: path,\n        doCommit: this.doImmediateCommit\n      });\n      return 0;\n    } catch (error) {\n      consoleDotError(`Error creating directory ${path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_rmdir(path) {\n    if (!this.workerThread) await this.initializeWorker();\n    consoleDotLog(`Removing directory: ${path}`);\n    try {\n      const exists = await this.workerThread.execute('isDirectoryDot', { path });\n      if (!exists.exists) {\n        throw new Error(`ENOENT: no such directory, rmdir '${path}'`);\n      }\n      if (!exists.isDirectory) {\n        throw new Error(`ENOTDIR: not a directory, rmdir '${path}'`);\n      }\n\n      // Check if directory is empty\n      const dirContents = await this.fs_readdir(path);\n      if (dirContents.length > 0) {\n        throw new Error(`ENOTEMPTY: directory not empty, rmdir '${path}'`);\n      }\n\n      await this.workerThread.execute('removeDirDot', {\n        dirPath: path,\n        doCommit: this.doImmediateCommit\n      });\n      return 0;\n    } catch (error) {\n      consoleDotError(`Error removing directory ${path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_rename(oldPath, newPath) {\n    if (!this.workerThread) await this.initializeWorker();\n    consoleDotLog(`Renaming ${oldPath} to ${newPath}`);\n    try {\n      // Check if oldPath exists\n      const oldExists = await this.workerThread.execute('isDirectoryDot', { path: oldPath });\n      if (!oldExists.exists) {\n        throw new Error(`ENOENT: no such file or directory, rename '${oldPath}' -> '${newPath}'`);\n      }\n\n      // Check if newPath's parent directory exists\n      const newParentDir = newPath.split('/').slice(0, -1).join('/');\n      if (newParentDir) {\n        const parentExists = await this.workerThread.execute('isDirectoryDot', { path: newParentDir });\n        if (!parentExists.exists || !parentExists.isDirectory) {\n          throw new Error(`ENOENT: no such directory, rename '${oldPath}' -> '${newPath}'`);\n        }\n      }\n\n      await this.workerThread.execute('rename', {\n        oldPath,\n        newPath\n      });\n      return 0;\n    } catch (error) {\n      consoleDotError(`Error renaming ${oldPath} to ${newPath}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_opendir(path) {\n    if (!this.workerThread) await this.initializeWorker();\n    consoleDotLog(`Opening directory: ${path}`);\n    try {\n      const exists = await this.workerThread.execute('isDirectoryDot', { path });\n      if (!exists.exists) {\n        throw new Error(`ENOENT: no such directory, opendir '${path}'`);\n      }\n      if (!exists.isDirectory) {\n        throw new Error(`ENOTDIR: not a directory, opendir '${path}'`);\n      }\n\n      await this.workerThread.execute('opendir', { path });\n      return 0;\n    } catch (error) {\n      consoleDotError(`Error opening directory ${path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_readdir(path, options = {}) {\n    consoleDotLog(`Reading directory: ${path}`);\n    try {\n      if (!this.workerThread) await this.initializeWorker();\n\n      const exists = await this.workerThread.execute('isDirectoryDot', { path });\n      if (!exists.exists) {\n        throw new Error(`ENOENT: no such directory, readdir '${path}'`);\n      }\n      if (!exists.isDirectory) {\n        throw new Error(`ENOTDIR: not a directory, readdir '${path}'`);\n      }\n\n      const result = await this.workerThread.execute('readDirDot', { path });\n      const dirEntries = result?.entries || [];\n\n      return dirEntries.map(entry => ({ path: entry.path, type: (entry.type === 'tree' ? 'dir' : 'file') }));\n      \n    } catch (error) {\n      consoleDotError(`Error reading directory ${path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_feof(fd) {\n    consoleDotLog(`Checking EOF for file descriptor: ${fd}`);\n    const file = this.fileDescriptors.get(fd);\n    if (!file) {\n      throw new Error(`EBADF: bad file descriptor, eof '${fd}'`);\n    }\n\n    try {\n      if (!this.workerThread) await this.initializeWorker();\n      const data = await this.workerThread.execute('readFileDot', { filePath: file.path }).catch(() => \"\");\n      consoleDotLog(`Current data in file ${file.path}:`, data);\n      const eof = file.pos >= data.length;\n      consoleDotLog(`EOF status for file ${file.path}: ${eof}`);\n      return eof;\n    } catch (error) {\n      consoleDotError(`Error checking EOF for file ${file.path}:`, error);\n      throw error;\n    }\n  }\n\n  async fs_fflush(fd) {\n    consoleDotLog(`Flushing file descriptor: ${fd}`);\n    return 0;\n  }\n\n  async fs_fcloseall() {\n    consoleDotLog(\"Closing all file descriptors.\");\n    this.fileDescriptors.clear();\n    return 0;\n  }\n}\n\nexport { IDBFs };","// GitAuth.js\nimport { Logger } from \"../LoggerES6.js\";\nimport { config } from '../../configES6.js';\n\nconst logger = new Logger(config.logging.GitAuth);\n\nfunction consoleDotLog(...parameters) {\n  logger.consoleDotLog(...parameters);\n}\n\nfunction consoleDotError(...parameters) {\n  logger.consoleDotError(...parameters);\n}\n\nexport class GitAuth {\n  constructor(workerThread) {\n    this.workerThread = workerThread;\n    this.AuthChecked = false;\n  }\n\n  /**\n   * Sets authentication credentials for Git operations\n   * @param {string} username \n   * @param {string} password \n   * @returns {Promise<boolean>}\n   */\n  async setAuthParams(username, password) {\n    try {\n      if (!this.workerThread) {\n        throw new Error('Worker thread not initialized');\n      }\n      \n      await this.workerThread.execute('setAuthParams', { username, password });\n      consoleDotLog('Auth params set successfully');\n      if (!this.AuthChecked) {\n        // await this.verifyAuth();\n        this.AuthChecked = true;\n      }\n      consoleDotLog('Auth params verified successfully');\n      return true;\n    } catch (error) {\n      consoleDotError('Failed to set auth params:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Verifies if current auth credentials are valid\n   * @returns {Promise<boolean>}\n   */\n  async verifyAuth() {\n    try {\n      if (!this.workerThread) {\n        throw new Error('Worker thread not initialized');\n      }\n\n      // Try a lightweight operation that requires auth\n      // It is not permanent, because a repo can require no auth for clone\n      await this.workerThread.execute('listServerRefs');\n      consoleDotLog('Auth verification successful');\n      return true;\n    } catch (error) {\n      if (error.toString().includes('401') || error.toString().includes('403')) {\n        consoleDotLog('Auth verification failed - invalid credentials');\n        return false;\n      }\n      consoleDotError('Auth verification error:', error);\n      throw error;\n    }\n  }\n\n    /**\n     * Sets Git user config (name and email)\n     * @param {string} name \n     * @param {string} email \n     */\n    async setUserConfig(name, email) {\n        try {\n        await this.workerThread.execute('setConfigs', { name, email });\n        consoleDotLog(`User config set, name: ${name}, email: ${email}`);\n        return true;\n        } catch (error) {\n        consoleDotError(`Failed to set user config: ${error}`);\n        throw error;\n        }\n    }\n}","import { Logger } from \"../LoggerES6.js\";\nimport { workerPool } from '../../WorkerPool.js';\nimport { config } from '../../configES6.js';\nimport { GitAuth } from './gitAuth.js';\n\nconst logger = new Logger(config.logging.VFSutils);\n\nfunction consoleDotLog(...parameters) {\n  logger.consoleDotLog('[ VFSUtils ]' , ...parameters);\n}\n\nfunction consoleDotError(...parameters) {\n  logger.consoleDotError('[ VFSUtils ]' , ...parameters);\n}\n\nconsoleDotLog(\"Loading VFSUtils module\");\n\nexport class VFSutils {\n  constructor(fsType, fsInstance, fsName, fetchInfo, useSW = false) {\n    this.fsType = fsType;\n    this.fsInstance = fsInstance;\n    this.fsName = fsName;\n    this.fetchInfo = fetchInfo;\n    this.workerEntry = null;\n    this.workerThread = null;\n    this.inodeCounter = 12341;\n    this.fsTable = {};\n    this.initialized = false;\n    this.useSW = useSW;\n    this.auth = null;\n  }\n\n  async initialize() {\n    if (this.initialized) return;\n    \n    try {\n      this.workerEntry = await workerPool.getWorker(this.fsName, this.useSW);\n      this.workerThread = this.workerEntry.thread;\n      \n      consoleDotLog('Setting Fs for VFSUtils.')\n      await this.workerThread.execute('setFs', {\n        fsName: this.fsName,\n        fsType: this.fsType,\n      });\n      \n      \n      consoleDotLog('Fs set.')\n      if (this.fetchInfo.corsProxy) {\n        await this.workerThread.execute('setCorsProxy', {\n          corsProxy: this.fetchInfo.corsProxy,\n        });\n      }\n      consoleDotLog('workerThread:', this.workerThread);\n      this.auth = new GitAuth(this.workerThread);\n\n      if (this.fetchInfo.username && this.fetchInfo.password) {\n        await this.setAuthParams(this.fetchInfo.username, this.fetchInfo.password);\n      }\n\n      this.initialized = true;\n      consoleDotLog(`VFSutils initialized for ${this.fsName} with type ${this.fsType}`);\n    } catch (error) {\n      await this.terminate();\n      throw error;\n    }\n  }\n\n  async terminate(fsName = null, fsType = null) {\n    try {\n      if (fsName && fsType) {\n        try {\n          consoleDotLog('Terminating VFSUtils...', fsName, fsType);\n          await this.workerThread.execute('handleDeleteCloseAndReclone', {\n            fsName: fsName,\n            fsType: fsType,\n            reclone: true,\n          });\n        } catch (error) {\n          consoleDotError(`Some error happend while terminating VFS: `, error);\n          throw error;\n        }\n      }\n      \n      if (this.workerEntry) {\n        await workerPool.releaseWorker(this.fsName);\n        this.workerEntry = null;\n        this.workerThread = null;\n      }\n      this.initialized = false;\n      return true;\n    } catch (error) {\n      consoleDotError(\"VFSutils termination error:\", error);\n      return false;\n    }\n  }\n\n  async fetchFromGit() {\n    try {\n      consoleDotLog('Fetching from Git repository...');\n      if (!this.initialized) await this.initialize();\n      consoleDotLog('initialized.')\n      const { url, dir = '/' } = this.fetchInfo;\n      \n      consoleDotLog(`Cloning repository from ${url} to ${dir}`);\n      const cloneResult = await this.workerThread.execute('doCloneAndStuff', { url });\n      // Fetch notes then\n      await this.fetchNotes();\n\n      if (!cloneResult.success) {\n        throw new Error(\"Fetching from git failed!\");\n      }\n\n      if (this.fetchInfo.name && this.fetchInfo.email) {\n        await this.setUserConfig(this.fetchInfo.name, this.fetchInfo.email);\n      }\n\n      // Generate FS table after successful clone\n      await this.generateFsTable();\n      consoleDotLog('Repository successfully cloned and indexed');\n    } catch (error) {\n      consoleDotError(`Git fetch failed: ${error}`);\n      await this.terminate();\n      throw error;\n    }\n  }\n\n  async fetchFromDisk() {\n    try {\n      if (!this.initialized) await this.initialize();\n      const { dir } = this.fetchInfo;\n      consoleDotLog(`Loading filesystem from disk at ${dir}`);\n      \n      // Implement disk loading logic here\n      await this.generateFsTable();\n      consoleDotLog(`Successfully loaded filesystem from disk`);\n    } catch (error) {\n      consoleDotError(`Disk load failed: ${error.message}`);\n      await this.terminate();\n      throw error;\n    }\n  }\n\n  async fetchFromGoogleDrive() {\n    try {\n      if (!this.initialized) await this.initialize();\n      const { fileId } = this.fetchInfo;\n      consoleDotLog(`Fetching from Google Drive file ${fileId}`);\n      \n      // Implement Google Drive loading logic here\n      await this.generateFsTable();\n      consoleDotLog(`Successfully fetched from Google Drive`);\n    } catch (error) {\n      consoleDotError(`Google Drive fetch failed: ${error.message}`);\n      await this.terminate();\n      throw error;\n    }\n  }\n\n  /* FS Table Management */\n  async generateFsTable() {\n    try {\n      if (!this.initialized) await this.initialize();\n      \n      consoleDotLog('Generating FS table...');\n      const fileList = await this.workerThread.execute('listFilesDot', { listDirs: true });\n      consoleDotLog('File list:', fileList);\n      this.fsTable = this.buildHierarchicalFsTable(fileList);\n      \n      consoleDotLog('FS table generated with', \n        Object.keys(this.fsTable['/'].children).length, 'root entries');\n      return this.fsTable;\n    } catch (error) {\n      consoleDotError('FS table generation failed:', error);\n      throw error;\n    }\n  }\n\n  buildHierarchicalFsTable(fileList) {\n    const root = this.createRootEntry();\n    \n    fileList.forEach(entry => {\n      const pathParts = entry.path.split('/').filter(p => p !== '');\n      let current = root;\n      \n      pathParts.forEach((part, index) => {\n        const isLast = index === pathParts.length - 1;\n        \n        // If current node doesn't exist or isn't a directory, create it\n        if (current.children[part]) {\n          const existing = current.children[part];\n          const expectedType = isLast && entry.type !== 'tree' ? 'file' : 'directory';\n        \n          if (existing.type !== expectedType) {\n            throw new Error(\n              `FS conflict: ${entry.path} has ${expectedType} where ${existing.type} already exists`\n            );\n          }\n        } else {\n          current.children[part] = this.createFsTableEntry(\n            part,\n            isLast && entry.type !== 'tree' ? 'file' : 'directory',\n            entry.size || 0,\n            current.dentry_id\n          );\n        }    \n        \n        // Only traverse into directories\n        if (!isLast) {\n          // Ensure the node we're moving into is a directory\n          if (current.children[part].type !== 'directory') {\n            // Convert existing file to directory if needed\n            current.children[part] = {\n              ...current.children[part],\n              type: 'directory',\n              children: {}\n            };\n          }\n          current = current.children[part];\n        }\n      });\n    });\n    \n    return { \"/\": root };\n  }\n\n  async updateFsTable(action, path, type = \"file\", size = 0) {\n    try {\n        // Normalize the path (remove leading/trailing slashes)\n        const normalizedPath = path.replace(/^\\/+|\\/+$/g, '');\n        \n        // Ensure root exists\n        if (!this.fsTable['/']) {\n            this.fsTable['/'] = this.createRootEntry();\n        }\n\n        const pathParts = normalizedPath.split('/');\n        let current = this.fsTable['/'];\n\n        // Special case: removing root (should never happen)\n        if (action === 'remove' && pathParts.length === 0) {\n            throw new Error('Cannot remove root directory');\n        }\n\n        // Traverse the path\n        for (let i = 0; i < pathParts.length - 1; i++) {\n            const part = pathParts[i];\n            \n            if (!current.children || !current.children[part]) {\n                if (action === 'remove') {\n                    // For removal, parent must exist\n                    throw new Error(`Parent path not found: ${pathParts.slice(0, i+1).join('/')}`);\n                }\n                // For creation, create intermediate directories\n                current.children[part] = this.createFsTableEntry(\n                    part, \n                    'directory', \n                    0, \n                    current.dentry_id\n                );\n            }\n            \n            current = current.children[part];\n        }\n\n        const name = pathParts[pathParts.length - 1];\n\n        switch (action) {\n            case 'create':\n                if (!current.children) {\n                    current.children = {};\n                }\n                \n                // Check if already exists\n                if (current.children[name]) {\n                    consoleDotLog(`path ${path} already exists, updating its content`);\n                }\n                \n                current.children[name] = this.createFsTableEntry(\n                    name, \n                    type, \n                    size, \n                    current.dentry_id\n                );\n                break;\n                \n            case 'remove':\n                if (!current.children || !current.children[name]) {\n                    // Return false instead of throwing error for non-existent paths\n                    return { success: false, message: `Path not found: ${path}` };\n                }\n                \n                // Check if trying to remove non-empty directory\n                if (current.children[name].type === 'directory' && \n                    Object.keys(current.children[name].children || {}).length > 0) {\n                    throw new Error(`Cannot remove non-empty directory: ${path}`);\n                }\n                \n                delete current.children[name];\n                break;\n                \n            default:\n                throw new Error(`Invalid action: ${action}`);\n        }\n\n        return { success: true, fsTable: this.fsTable };\n    } catch (error) {\n        consoleDotError('FS table update failed:', error);\n        throw error;\n    }\n}\n\n  createRootEntry() {\n    return {\n      type: \"directory\",\n      dentry_id: this.inodeCounter++,\n      name: \"\",\n      parent_inode: 0,\n      acl: { owner: \"root\", permissions: \"rwx\", groups: { \"users\": \"r\" } },\n      children: {},\n      ctime: Date.now(),\n      mtime: Date.now()\n    };\n  }\n\n  createFsTableEntry(name, type, size, parentInode) {\n    const isDir = type === \"directory\";\n    return {\n      inode: this.inodeCounter++,\n      type,\n      name,\n      mode: isDir ? 16877 : 100644,\n      size: isDir ? 0 : size,\n      uid: 1000,\n      gid: 100,\n      parent_inode: parentInode,\n      acl: { \n        owner: \"user\", \n        permissions: isDir ? \"rwx\" : \"rw-\", \n        groups: { users: \"r\" } \n      },\n      children: isDir ? {} : undefined,\n      ctime: Date.now(),\n      mtime: Date.now()\n    };\n  }\n\n  async getFsTableSize(fsTable) {\n    try {\n      return fsTable ? JSON.stringify(fsTable).length : 0;\n    } catch (error) {\n      consoleDotError('Size calculation failed:', error);\n      return 0;\n    }\n  }\n\n  async commitStagedChanges( message ) {\n    try {\n      if (!this.initialized) await this.initialize();\n\n      await this.workerThread.execute('setFs', {\n        fsName: this.fsName,\n        fsType: this.fsType,\n      });\n\n      return await this.workerThread.execute('commitStagedChanges', { message });\n    } catch (error) {\n      consoleDotError('Version commit failed:', error);\n      throw error;\n    } \n  }\n\n  // -------------------\n  //  Merging Methods\n  // -------------------\n\n      /**\n       * Optimized sync status check with minimal remote operations\n       */\n      async getSyncStatus(_url = null, ref = 'main') {\n        try {\n          consoleDotLog('Starting sync status check...');\n          const url = _url || this.fetchInfo?.url;\n          \n          // Get local head\n          consoleDotLog('Getting local head commit...');\n          const localHead = await this.workerThread.execute('getLastLocalCommit', { ref });\n          consoleDotLog('Local head commit:', localHead);\n          \n          // Get remote head\n          consoleDotLog('Getting remote head commit...');\n          const remoteResult = await this.workerThread.execute('getLatestRemoteCommit', { \n            url, \n            ref,\n          });\n          consoleDotLog('Remote head result:', remoteResult);\n      \n          if (!remoteResult.success) {\n            consoleDotLog('Remote branch not found');\n            return {\n              status: 'remote-branch-not-found',\n              localHead,\n              remoteHead: null\n            };\n          }\n      \n          const remoteHead = remoteResult.commit;\n          consoleDotLog('Remote head commit:', remoteHead);\n          \n          // Fast path if heads match\n          if (localHead === remoteHead) {\n            consoleDotLog('Local and remote heads match - up to date');\n            return {\n              status: 'up-to-date',\n              localHead,\n              remoteHead\n            };\n          }\n      \n          // Get commit histories\n          consoleDotLog('Getting commit histories...');\n          const [localCommits, remoteCommits] = await Promise.all([\n            await this.getLocalCommitHistory(10),\n            await this.getRemoteCommitHistory(10)\n          ]);\n          \n          consoleDotLog('Local commits (10 most recent):', localCommits);\n          consoleDotLog('Remote commits (10 most recent):', remoteCommits);\n      \n          // Find common commit\n          const commonCommit = this.findFirstCommonCommit(localCommits, remoteCommits);\n          consoleDotLog('Common commit found:', commonCommit);\n          \n          let status;\n          if (!commonCommit) {\n            status = 'diverged';\n            consoleDotLog('No common commit found - branches have diverged');\n          } else if (commonCommit === remoteHead) {\n            status = 'local-ahead';\n            consoleDotLog('Local is ahead of remote');\n          } else if (commonCommit === localHead) {\n            status = 'remote-ahead';\n            consoleDotLog('Remote is ahead of local');\n          } else {\n            status = 'diverged';\n            consoleDotLog('Branches have diverged');\n          }\n      \n          return {\n            status,\n            localHead,\n            remoteHead,\n            commonAncestor: commonCommit\n          };\n        } catch (err) {\n          consoleDotError(\"getSyncStatus failed:\", err);\n          return {\n            status: 'error',\n            error: err.message\n          };\n        }\n      }\n\n      /**\n       * Find first common commit between two commit lists\n       */\n      findFirstCommonCommit(localCommits, remoteCommits) {\n        const remoteSet = new Set(remoteCommits);\n        for (const commit of localCommits) {\n          if (remoteSet.has(commit)) {\n            return commit;\n          }\n        }\n        return null;\n      }\n\n      /**\n       * Get local commit history\n       */\n      async getLocalCommitHistory(depth = 10) {\n        try {\n          const logs = await this.workerThread.execute('log', {\n            depth,\n          });\n          const commits = logs.map(commit => commit.oid);\n          consoleDotLog('GetLocalCommitHistory result: ', commits);\n          return commits || [];\n        } catch (error) {\n          consoleDotError(\"Failed to get local commit history:\", error);\n          return [];\n        }\n      }\n\n      /**\n       * Get remote commit history by fetching from replica\n       */\n      async getRemoteCommitHistory(depth = 10) {\n        try {\n          consoleDotLog('Fetching remote commit history with depth:', depth);\n          const result = await this.workerThread.execute('getCommitHistoryFromReplica', {\n            depth,\n          });\n          \n          consoleDotLog('Raw result from worker:', result);\n          \n          // Handle both direct array response and success/commits object structure\n          if (Array.isArray(result)) {\n            consoleDotLog('Received direct commits array:', result);\n            return result;\n          } else if (result && (result.commits || result.success)) {\n            consoleDotLog('Received structured response with commits:', result.commits || []);\n            return result.commits || [];\n          } else {\n            consoleDotError('Unexpected response format:', result);\n            return [];\n          }\n        } catch (error) {\n          consoleDotError(\"Failed to get remote commit history:\", error);\n          return [];\n        }\n      }\n\n      /**\n       * Optimized sync flow that minimizes remote operations\n       */\n      async autoSyncFlow(onConflictStrategy) {\n        try {\n          consoleDotLog('this.fetchInfo', this.fetchInfo);\n          // First do lightweight check\n          const { status, localHead, remoteHead, commonAncestor } = await this.getSyncStatus();\n          \n          consoleDotLog(\"Sync status:\", status);\n          \n          switch (status) {\n            case 'up-to-date':\n              return { synced: true };\n              \n            case 'local-ahead':\n              return await this.handleLocalAhead(localHead, remoteHead, onConflictStrategy);\n              \n            case 'remote-ahead':\n              return await this.handleRemoteAhead(localHead, remoteHead, onConflictStrategy);\n              \n            case 'diverged':\n              return await this.handleDiverged(localHead, remoteHead, commonAncestor, onConflictStrategy);\n              \n            case 'remote-branch-not-found':\n              consoleDotError('Remote branch not found');\n              return { synced: false, error: 'Remote branch not found' };\n              \n            default:\n              throw new Error(`Unknown sync status: ${status}`);\n          }\n        } catch (err) {\n          consoleDotError(\"autoSyncFlow failed:\", err);\n          throw err;\n        }\n      }\n\n      /**\n       * Handle case where remote is ahead of local (need to pull changes)\n       */\n      async handleRemoteAhead(localHead, remoteHead, onConflictStrategy) {\n        try {\n          consoleDotLog(`Handling remote-ahead scenario (local: ${localHead}, remote: ${remoteHead})`);\n          const _onConflictStrategy = onConflictStrategy || 'theirs';\n          // 1. First try a simple fast-forward\n          consoleDotLog('Attempting fast-forward merge...');\n          const ffResult = await this.workerThread.execute('fastForward', {\n            url: this.fetchInfo.url,\n            ref: 'main',\n          });\n          \n          if (ffResult.success) {\n            consoleDotLog('Fast-forward successful');\n            await this.generateFsTable(); // Refresh FS table\n            return { \n              synced: true, \n              strategy: 'fast-forward',\n              oldHead: localHead,\n              newHead: remoteHead\n            };\n          }\n          \n          // 2. If fast-forward fails, do a full pull with merge\n          consoleDotLog('Fast-forward failed, attempting full pull...');\n          const pullResult = await this.workerThread.execute('doFetch', {\n            url: this.fetchInfo.url,\n            ref: 'main',\n          });\n          consoleDotLog('Fetching notes from remote...');\n          await this.workerThread.execute('doFetch', {\n            url: this.fetchInfo.url,\n            remote: 'origin',\n            ref: 'refs/notes/commits',\n            tags: true,\n            singleBranch: true,\n          });\n          const mergeResult = await this.workerThread.execute('merge', {\n            ours : 'main',\n            theirs : 'origin/main',\n            strategy: _onConflictStrategy,\n          });\n\n          consoleDotLog('Fetching notes from remote...');\n          await this.workerThread.execute('doFetch', {\n            url: this.fetchInfo.url,\n            remote: 'origin',\n            ref: 'refs/notes/commits',\n            tags: true,\n            singleBranch: true,\n          });\n          \n          if (!pullResult.success) {\n            throw new Error('Pull failed: ' + (pullResult.error || 'Unknown error'));\n          }\n          \n          consoleDotLog('Pull successful');\n          await this.generateFsTable(); // Refresh FS table\n          \n          // Verify new head matches remote\n          const newLocalHead = await this.workerThread.execute('getLastLocalCommit', { ref: 'main' });\n          if (newLocalHead !== remoteHead) {\n            consoleDotLog(`Warning: Local head (${newLocalHead}) doesn't match remote head (${remoteHead}) after pull`);\n          }\n          \n          return { \n            synced: true, \n            strategy: 'pull-with-merge',\n            oldHead: localHead,\n            newHead: newLocalHead\n          };\n        } catch (error) {\n          consoleDotError('handleRemoteAhead failed:', error);\n          \n          // Attempt to reset to original state if something went wrong\n          try {\n            await this.workerThread.execute('resetToCommit', { \n              oid: localHead,\n              hard: true \n            });\n          } catch (resetError) {\n            consoleDotError('Failed to reset after error:', resetError);\n          }\n          \n          throw error;\n        }\n      }\n\n      /**\n       * Handle case where local is ahead of remote (need to push changes)\n       */\n      async handleLocalAhead(localHead, remoteHead) {\n        try {\n          consoleDotLog(`Handling local-ahead scenario (local: ${localHead}, remote: ${remoteHead})`);\n          \n          await this.setAuthParams(this.fetchInfo.username, this.fetchInfo.password);\n\n          const pushNotesResult = await this.workerThread.execute('push', {\n            url: this.fetchInfo.url,\n            ref: 'refs/notes/commits',\n            remoteRef: 'refs/notes/commits',\n            force: false,\n          });\n                    consoleDotLog('Attempting push...');\n          const pushResult = await this.workerThread.execute('push', {\n            url: this.fetchInfo.url,\n            ref: 'main',\n            force: false,\n          });\n          \n          if (pushResult.success || pushNotesResult.success) {\n            consoleDotLog('Push successful');\n            return { \n              synced: true, \n              strategy: 'push',\n              oldRemoteHead: remoteHead,\n              newRemoteHead: localHead\n            };\n          }\n          \n          consoleDotLog('Push failed, rechecking sync status...');\n          const newStatus = await this.getSyncStatus();\n          \n          if (newStatus.status === 'up-to-date') {\n            consoleDotLog('Status is now up-to-date after push failure');\n            return { synced: true, strategy: 'concurrent-update' };\n          }\n          \n          if (newStatus.status === 'remote-ahead') {\n            consoleDotLog('Remote moved ahead during push attempt');\n            return this.handleRemoteAhead(localHead, newStatus.remoteHead);\n          }\n          \n          if (newStatus.status === 'diverged') {\n            consoleDotLog('Branches diverged during push attempt');\n            return this.handleDiverged(localHead, newStatus.remoteHead, newStatus.commonAncestor);\n          }\n          \n          throw new Error(`Unexpected status after push failure: ${newStatus.status}`);\n        } catch (error) {\n          consoleDotError('handleLocalAhead failed:', error);\n          throw error;\n        }\n      }\n\n      /**\n       * Handle case where branches have diverged\n       */\n      async handleDiverged(localHead, remoteHead, commonAncestor, onConflictStrategy) {\n        try {\n          const _onConflictStrategy = onConflictStrategy || 'theirs';\n\n          consoleDotLog('Using merge workflow');\n          \n          // 1. Pull with merge\n          consoleDotLog('Pulling with merge...');\n          const pullResult = await this.workerThread.execute('doFetch', {\n            url: this.fetchInfo.url,\n            ref: 'main',\n          });\n\n          consoleDotLog('Fetching notes from remote...');\n          await this.workerThread.execute('doFetch', {\n            url: this.fetchInfo.url,\n            remote: 'origin',\n            ref: 'refs/notes/commits',\n            tags: true,\n            singleBranch: true,\n          });\n          const mergeResult = await this.workerThread.execute('merge', {\n            ours : 'main',\n            theirs : 'origin/main',\n            strategy : _onConflictStrategy,\n          });\n          \n          if (!pullResult.success) {\n            throw new Error('Pull failed: ' + (pullResult.error || 'Unknown error'));\n          }\n\n\n          const pushNotesResult = await this.workerThread.execute('push', {\n            url: this.fetchInfo.url,\n            ref: 'refs/notes/commits',\n            remoteRef: 'refs/notes/commits',\n            force: false,\n          });\n          consoleDotLog('Pushing merged changes...');\n          await this.setAuthParams(this.fetchInfo.username, this.fetchInfo.password);\n          const pushResult = await this.workerThread.execute('push', {\n            url: this.fetchInfo.url,\n            ref: 'main',\n            force: false,\n          });\n          \n          return { \n            synced: true, \n            strategy: 'merge-workflow',\n            oldLocalHead: localHead,\n            newLocalHead: await this.workerThread.execute('getLastLocalCommit', { ref: 'main' }),\n            remoteHead\n          };\n        } catch (error) {\n          consoleDotError('handleDiverged failed:', error);\n          \n          // Attempt to reset to original state\n          try {\n            await this.workerThread.execute('resetToCommit', { \n              oid: localHead,\n              hard: true \n            });\n          } catch (resetError) {\n            consoleDotError('Failed to reset after error:', resetError);\n          }\n          \n          throw error;\n        }\n      }\n      \n      // ------------------------\n      //  Authentication Methods\n      // ------------------------\n\n      /**\n       * Sets authentication credentials\n       * @param {string} username \n       * @param {string} password \n       * @returns {Promise<boolean>}\n       */\n      async setAuthParams(username, password) {\n        return this.auth.setAuthParams(username, password);\n      }\n\n      /**\n       * Sets Git user config (name and email)\n       * @param {string} name\n       * @param {string} email\n       * @returns {Promise<void>}\n       */\n      async setUserConfig(name, email) {\n        return this.auth.setUserConfig(name, email);\n      }\n      \n      /**\n       * Verifies if current auth credentials are valid\n       * @returns {Promise<boolean>}\n       */\n      async verifyAuth() {\n        return this.auth.verifyAuth();\n      }\n\n      async updateFetchInfo(args) {\n        try {\n          const newFetchInfo = args || {};\n          if (!this.initialized) await this.initialize();\n          this.fetchInfo = { ...this.fetchInfo, ...newFetchInfo };\n          consoleDotLog('Fetch info updated:', this.fetchInfo);\n          return this.fetchInfo;\n        } catch(error) {\n          consoleDotError('Some error happened while using updateFetchInfo');\n          throw new Error('Some error happened while using updateFetchInfo');\n        }\n      }\n\n      // ------------------\n      //  Helper functions\n      // ------------------\n\n      async fetchNotes() {\n        try {\n          await this.reconfigureRemoteWithNotes();\n          const serverRefs = await this.workerThread.execute('listServerRefs', {\n            remote: 'origin'\n          });\n          \n          const hasNotes = serverRefs.refs.some(row => row.ref === 'refs/notes/commits');\n\n          if (hasNotes) {\n            consoleDotLog('Fetching notes from remote...');\n            await this.workerThread.execute('doFetch', {\n              url: this.fetchInfo.url,\n              remote: 'origin',\n              ref: 'refs/notes/commits',\n              tags: true,\n              singleBranch: true,\n            });\n\n            consoleDotLog('Notes Fetch is done.')\n          }\n        } catch (error) {\n          consoleDotError('Failed to fetch notes:', error);\n          // Don't throw - notes are optional\n        }\n      }\n\n      async reconfigureRemoteWithNotes() {\n        try {\n          const fetch = await this.workerThread.execute('getConfig', {\n            path: 'remote.origin.fetch',\n          });\n          \n          if (fetch !== '+refs/notes/*:refs/notes/*') {\n              await this.workerThread.execute('setConfig', {\n              path: 'remote.origin.fetch',\n              value: '+refs/notes/*:refs/notes/*',\n              args: { append: true }\n            });\n          }\n\n          consoleDotLog('Successfully reconfigured remote with notes fetch');\n        } catch (error) {\n          consoleDotError('Failed to reconfigure remote:', error);\n          throw error;\n        }\n      }\n}","export class StorageUtils {\n  constructor(dbName = \"VFS_Mounts\") {\n    this.dbName = dbName;\n    this.localStorageWarningShown = false;\n    this.forceLocalStorage = false;\n  }\n\n  supportsIndexedDB() {\n    if (this.forceLocalStorage) return false;\n    try {\n      return typeof window !== \"undefined\" && !!window.indexedDB;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  async ensureObjectStoreExists() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.dbVersion);\n      \n      request.onerror = () => {\n        console.error(\"IndexedDB open error:\", request.error);\n        resolve(false);\n      };\n      \n      request.onsuccess = () => {\n        const db = request.result;\n        if (db.objectStoreNames.contains(\"mounts\")) {\n          resolve(true);\n        } else {\n          resolve(false);\n        }\n        db.close();\n      };\n      \n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        if (!db.objectStoreNames.contains(\"mounts\")) {\n          db.createObjectStore(\"mounts\");\n          console.log(\"Created 'mounts' object store\");\n        }\n      };\n    });\n  }\n\n  /** Simplified localStorage methods with error handling */\n  async getFromLocalStorage(key) {\n    try {\n      if (typeof localStorage === \"undefined\") return null;\n      const item = localStorage.getItem(key);\n      return item ? JSON.parse(item) : null;\n    } catch (e) {\n      console.error(\"LocalStorage get error:\", e);\n      return null;\n    }\n  }\n\n  async getFromIndexedDB(key) {\n    const hasObjectStore = await this.ensureObjectStoreExists();\n    if (!hasObjectStore) return null;\n\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.dbVersion);\n      request.onerror = () => resolve(null);\n      request.onsuccess = () => {\n        const db = request.result;\n        try {\n          const transaction = db.transaction(\"mounts\", \"readonly\");\n          const store = transaction.objectStore(\"mounts\");\n          const getRequest = store.get(key);\n\n          getRequest.onsuccess = () => resolve(getRequest.result || null);\n          getRequest.onerror = () => resolve(null);\n        } catch (error) {\n          console.error(\"Transaction error:\", error);\n          resolve(null);\n        } finally {\n          db.close();\n        }\n      };\n    });\n  }\n\n  async getAll() {\n    if (this.supportsIndexedDB()) {\n      try {\n        return await this.getAllFromIndexedDB();\n      } catch (e) {\n        console.error(\"IndexedDB getAll failed:\", e);\n        // Fallback to localStorage\n        return await this.getAllFromLocalStorage();\n      }\n    }\n    return await this.getAllFromLocalStorage();\n  }\n\n  async getAllFromIndexedDB() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.dbVersion);\n      \n      request.onerror = () => resolve({});\n      request.onsuccess = () => {\n        const db = request.result;\n        if (!db.objectStoreNames.contains(\"mounts\")) {\n          resolve({});\n          return;\n        }\n  \n        const transaction = db.transaction(\"mounts\", \"readonly\");\n        const store = transaction.objectStore(\"mounts\");\n        const getAllKeysRequest = store.getAllKeys();\n        const result = {};\n  \n        getAllKeysRequest.onsuccess = async () => {\n          const keys = getAllKeysRequest.result;\n          \n          // Get each value by its exact key\n          for (const key of keys) {\n            const value = await this.get(key);\n            if (value) {\n              result[key] = value;\n            }\n          }\n          \n          resolve(result);\n        };\n        \n        getAllKeysRequest.onerror = () => resolve({});\n      };\n    });\n  }\n\n  async getAllFromLocalStorage() {\n    try {\n      if (typeof localStorage === \"undefined\") return {};\n      \n      const result = {};\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && key.startsWith(this.dbName)) {\n          try {\n            result[key] = JSON.parse(localStorage.getItem(key));\n          } catch (e) {\n            console.error(\"Error parsing localStorage item:\", e);\n          }\n        }\n      }\n      return result;\n    } catch (e) {\n      console.error(\"LocalStorage getAll error:\", e);\n      return {};\n    }\n  }\n\n  async storeInLocalStorage(key, data) {\n    try {\n      if (typeof localStorage === \"undefined\") return false;\n\n      const dataStr = JSON.stringify(data);\n\n      if (dataStr.length > 5000000) {\n        console.error(\"Data too large for localStorage\");\n        return false;\n      }\n\n      localStorage.setItem(key, dataStr);\n      return true;\n    } catch (e) {\n      console.error(\"LocalStorage set error:\", e);\n      if (e.name === \"QuotaExceededError\") {\n        this.forceLocalStorage = true;\n      }\n      return false;\n    }\n  }\n\n  async removeFromLocalStorage(key) {\n    try {\n      if (typeof localStorage === \"undefined\") return false;\n      localStorage.removeItem(key);\n      return true;\n    } catch (e) {\n      console.error(\"LocalStorage remove error:\", e);\n      return false;\n    }\n  }\n\n  async get(key) {\n    let value = null;\n\n    if (this.supportsIndexedDB()) {\n      try {\n        value = await this.getFromIndexedDB(key);\n      } catch (e) {\n        console.error(\"IndexedDB get failed:\", e);\n      }\n    }\n\n    if (value === null) {\n      try {\n        value = await this.getFromLocalStorage(key);\n      } catch (e) {\n        console.error(\"LocalStorage get fallback failed:\", e);\n      }\n    }\n\n    return value;\n  }\n\n  async store(key, data) {\n    let indexedSuccess = false;\n    let localSuccess = false;\n\n    if (this.supportsIndexedDB()) {\n      try {\n        indexedSuccess = await this.storeInIndexedDB(key, data);\n      } catch (e) {\n        console.error(\"IndexedDB store failed:\", e);\n      }\n    }\n\n    try {\n      localSuccess = await this.storeInLocalStorage(key, data);\n    } catch (e) {\n      console.error(\"LocalStorage store failed:\", e);\n    }\n\n    return indexedSuccess || localSuccess;\n  }\n\n  async remove(key) {\n    let success = true;\n\n    if (this.supportsIndexedDB()) {\n      try {\n        success = (await this.removeFromIndexedDB(key)) && success;\n      } catch (e) {\n        console.error(\"IndexedDB remove failed:\", e);\n        success = false;\n      }\n    }\n\n    try {\n      success = (await this.removeFromLocalStorage(key)) && success;\n    } catch (e) {\n      console.error(\"LocalStorage remove failed:\", e);\n      success = false;\n    }\n\n    return success;\n  }\n\n  async storeInIndexedDB(key, data) {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, 1);\n      request.onerror = () => resolve(false);\n      request.onsuccess = () => {\n        const db = request.result;\n        const transaction = db.transaction(\"mounts\", \"readwrite\");\n        const store = transaction.objectStore(\"mounts\");\n        store.put(data, key);\n        transaction.oncomplete = () => resolve(true);\n        transaction.onerror = () => resolve(false);\n      };\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        if (!db.objectStoreNames.contains(\"mounts\")) {\n          db.createObjectStore(\"mounts\");\n        }\n      };\n    });\n  }\n\n  async removeFromIndexedDB(key) {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, 1);\n      request.onerror = () => resolve(false);\n      request.onsuccess = () => {\n        const db = request.result;\n        const transaction = db.transaction(\"mounts\", \"readwrite\");\n        const store = transaction.objectStore(\"mounts\");\n        store.delete(key);\n        transaction.oncomplete = () => resolve(true);\n        transaction.onerror = () => resolve(false);\n      };\n    });\n  }\n}","import { Logger } from \"./../LoggerES6.js\";\nimport { config } from './../../configES6.js';\n\nconst logger = new Logger(config.logging.supportChecker);\n\nfunction consoleDotLog(...parameters) {\n  logger.consoleDotLog(...parameters);\n}\n\nexport async function checkIndexedDBSupport() {\n  try {\n    if (!window.indexedDB) {\n      consoleDotLog(\"IndexedDB not supported in this browser\");\n      return false;\n    }\n\n    // Test opening a dummy database to verify support\n    return await new Promise((resolve) => {\n      const dbName = \"testIDBSupport\";\n      const request = indexedDB.open(dbName);\n      \n      request.onerror = () => {\n        consoleDotLog(\"IndexedDB not available\");\n        resolve(false);\n      };\n      \n      request.onsuccess = (event) => {\n        const db = event.target.result;\n        db.close();\n        \n        // Delete the test database\n        const deleteRequest = indexedDB.deleteDatabase(dbName);\n        \n        deleteRequest.onerror = () => {\n          consoleDotLog(\"Failed to delete test database\");\n          resolve(true); // Still consider IDB supported\n        };\n        \n        deleteRequest.onsuccess = () => {\n          consoleDotLog(\"IndexedDB test successful\");\n          resolve(true);\n        };\n      };\n\n      request.onblocked = () => {\n        consoleDotLog(\"IndexedDB request blocked\");\n        resolve(false);\n      };\n    });\n  } catch (e) {\n    consoleDotLog(\"IndexedDB test failed:\", e);\n    return false;\n  }\n}\n\nexport const supportChecker = {\n  checkIndexedDBSupport\n};","import { MemoryFS } from './memoryFs.js';\nimport { IDBFs } from './IDBFs.js';\nimport { VFSutils } from \"./libs/vfsUtils/VFSUtils.js\";\nimport { Logger } from \"./libs/LoggerES6.js\";\nimport { StorageUtils } from './libs/vfsUtils/storageUtils.js';\nimport { checkIndexedDBSupport } from './libs/vfsUtils/supportChecker.js';\nimport { config } from './configES6.js';\n\nconst logger = new Logger(config.logging.vfs);\n\n// Logger Utilities\nfunction consoleDotLog(...parameters) {\n  logger.consoleDotLog('[VFS] ', ...parameters);\n}\n\nfunction consoleDotError(...parameters) {\n  logger.consoleDotError('[VFS] ', ...parameters);\n}\n\nexport class VFS {\n  constructor(storageName = \"VFS_Mounts\") {\n    this.mounts = Object.create(null);\n    this.initializedMounts = new Set();\n    this.vfsUtilsInstances = new Map();\n    this.storageUtils = new StorageUtils(storageName);\n    this.currentMountPath = '';\n    this.idbSupported = null;\n    (async () => {\n      try {\n        await this.retrieveAndMountFromFsTable();\n      } catch (error) {\n        consoleDotError('Automatic mount from fsTable failed:', error);\n      }\n    })();\n    consoleDotLog('VFS instance created');\n  }\n\n  // Environment detection utilities\n  getBrowserInfo() {\n    const userAgent = navigator.userAgent;\n    let browser = 'Unknown';\n    \n    if (userAgent.includes('Firefox')) browser = 'Firefox';\n    else if (userAgent.includes('SamsungBrowser')) browser = 'Samsung Browser';\n    else if (userAgent.includes('Opera') || userAgent.includes('OPR')) browser = 'Opera';\n    else if (userAgent.includes('Trident')) browser = 'IE';\n    else if (userAgent.includes('Edge')) browser = 'Edge';\n    else if (userAgent.includes('Chrome')) browser = 'Chrome';\n    else if (userAgent.includes('Safari')) browser = 'Safari';\n    \n    return browser;\n  }\n\n  getDeviceType() {\n    const userAgent = navigator.userAgent;\n    if (/(tablet|ipad|playbook|silk)|(android(?!.*mobi))/i.test(userAgent)) {\n      return 'Tablet';\n    }\n    if (/Mobile|Android|iP(hone|od)|IEMobile|BlackBerry|Kindle|Silk-Accelerated|(hpw|web)OS|Opera M(obi|ini)/.test(userAgent)) {\n      return 'Mobile';\n    }\n    return 'Desktop';\n  }\n\n  getPlatformInfo() {\n    return {\n      browser: this.getBrowserInfo(),\n      device: this.getDeviceType(),\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      screenResolution: `${window.screen.width}x${window.screen.height}`,\n      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n      language: navigator.language\n    };\n  }\n\n  // Utility functions for versioning and merging\n  getVersioningConfig(options = {}) {\n    const versioning = options.versioning || config.versioning || {};\n    return {\n      strategy: versioning.strategy,\n      interval: versioning.interval,\n      number: versioning.number\n    };\n  }\n\n  getMergingConfig(options = {}) {\n    const merging = options.merging || config.merging || {};\n    return {\n      strategy: merging.strategy || 'none',\n      conflictResolution: merging.conflictResolution || 'timestamp'\n    };\n  }\n\n  // Storage and Support Checking\n  async checkIndexedDBSupport() {\n    consoleDotLog('Checking IndexedDB support...');\n    if (this.idbSupported !== null) {\n      return this.idbSupported;\n    }\n    \n    try {\n      await checkIndexedDBSupport();\n      consoleDotLog('IndexedDB is supported');\n      this.idbSupported = true;\n      return true;\n    } catch (error) {\n      consoleDotError('IndexedDB not supported:', error);\n      this.idbSupported = false;\n      return false;\n    }\n  }\n\n  async determineUseSW(fsType, options) {\n    if (options.useSW !== undefined) {\n      return options.useSW;\n    }\n    \n    if (fsType === 'idb') {\n      const isSupported = await this.checkIndexedDBSupport();\n      return isSupported; // Only use SW if IDB is supported\n    }\n    \n    // Default to false for memory filesystem\n    return false;\n  }\n\n  async loadMountFromStorage(mountPath) {\n    consoleDotLog(`Attempting to load mount from storage: ${mountPath}`);\n    try {\n      const storedMount = await this.storageUtils.get(mountPath);\n      if (storedMount) {\n        consoleDotLog(`Successfully loaded mount from storage: ${mountPath}`);\n        return storedMount;\n      }\n      consoleDotLog(`No mount found in storage for path: ${mountPath}`);\n      return null;\n    } catch (error) {\n      consoleDotError(`Failed to load mount from storage (path: ${mountPath}):`, error);\n      throw error;\n    }\n  }\n\n  async persistMountData(mountPath, mountData) {\n    consoleDotLog(`Persisting mount data for ${mountPath}`);\n    try {\n      const dataToStore = { ...mountData };\n      delete dataToStore.fsInstance;\n      await this.storageUtils.store(mountPath, dataToStore);\n      consoleDotLog(`Successfully persisted mount data for ${mountPath}`);\n    } catch (error) {\n      consoleDotError(`Failed to persist mount data for ${mountPath}:`, error);\n      throw error;\n    }\n  }\n\n  // Filesystem Instance Management\n  async createFSInstance(fsType, mountPath, options = {}) {\n    consoleDotLog(`Creating FS instance of type ${fsType} for mount path ${mountPath}`);\n    try {\n      // Determine the actual useSW value based on filesystem type and support\n      const useSW = await this.determineUseSW(fsType, options);\n      \n      if (fsType === 'idb') {\n        consoleDotLog('Checking IndexedDB support for IDB FS');\n        const isSupported = await this.checkIndexedDBSupport();\n        if (!isSupported) {\n          consoleDotLog(`IndexedDB not supported, falling back to memory FS for ${mountPath}`);\n          fsType = 'memory';\n        }\n      }\n\n      let fsInstance;\n      switch (fsType) {\n        case 'memory':\n          consoleDotLog('Creating MemoryFS instance');\n          fsInstance = new MemoryFS(mountPath, { ...options, useSW: false }); // Always disable SW for memory FS\n          break;\n        case 'idb':\n          consoleDotLog('Creating IDBFs instance');\n          fsInstance = new IDBFs(mountPath, { ...options, useSW });\n          break;\n        default:\n          const errorMsg = `Unknown FS type: ${fsType}`;\n          consoleDotError(errorMsg);\n          throw new Error(errorMsg);\n      }\n\n      consoleDotLog(`Successfully created ${fsType} FS instance for ${mountPath}`);\n      return fsInstance;\n    } catch (error) {\n      consoleDotError(`Failed to create FS instance (type: ${fsType}, path: ${mountPath}):`, error);\n      throw error;\n    }\n  }\n\n  async ensureFSInitialized(fsPath) {\n    consoleDotLog(`Ensuring FS is initialized for path: ${fsPath}`);\n    if (this.initializedMounts.has(fsPath)) {\n      consoleDotLog(`FS already initialized for path: ${fsPath}`);\n      return true;\n    }\n    \n    const mountData = this.mounts[fsPath];\n    if (!mountData) {\n      const errorMsg = `Mount not found: ${fsPath}`;\n      consoleDotError(errorMsg);\n      throw new Error(errorMsg);\n    }\n    \n    if (!mountData.fsInstance) {\n      consoleDotLog(`Creating new FS instance for mount at ${fsPath}`);\n      const useSW = await this.determineUseSW(mountData.fsType, mountData);\n      mountData.fsInstance = await this.createFSInstance(\n        mountData.fsType, \n        fsPath, \n        { \n          useSW, \n          versioning: this.getVersioningConfig(mountData),\n          merging: this.getMergingConfig(mountData)\n        }\n      );\n    }\n    \n    consoleDotLog(`Fetching data for mount at ${fsPath}`);\n    await this.fetchFS(\n      mountData.fetchMethod, \n      mountData.fsType, \n      mountData.fsInstance, \n      fsPath, \n      mountData.fetchInfo\n    );\n    \n    this.initializedMounts.add(fsPath);\n    consoleDotLog(`Successfully initialized FS for path: ${fsPath}`);\n    return true;\n  }\n\n  // Mount/Unmount Operations\n  async mount(path, fsType, fsName, fetchMethod, options = {}) {\n    consoleDotLog(`Mounting filesystem - path: ${path}, type: ${fsType}, name: ${fsName}, method: ${fetchMethod}, options: ${JSON.stringify(options)}`);\n    try {\n      const fetchInfo = options.fetchInfo || {};\n      const versioning = this.getVersioningConfig(options);\n      const merging = this.getMergingConfig(options);\n      \n      const normalizedPath = path.endsWith('/') ? path : `${path}/`;\n      const mountPath = `${normalizedPath}${fsName}`;\n      consoleDotLog(`Normalized mount path: ${mountPath}`);\n      \n      if (this.mounts[mountPath]) {\n        const errorMsg = `Path ${mountPath} is already mounted`;\n        consoleDotError(errorMsg);\n        throw new Error(errorMsg);\n      }\n\n      this.currentMountPath = mountPath;\n      consoleDotLog(`Checking storage for existing mount at ${mountPath}`);\n      const storedMount = await this.loadMountFromStorage(mountPath);\n\n      if (storedMount) {\n        consoleDotLog(`Found stored mount, initializing existing mount at ${mountPath}`);\n        return this.initializeStoredMount(mountPath, storedMount, fetchMethod, fetchInfo, { versioning, merging });\n      }\n\n      consoleDotLog(`No stored mount found, creating new mount at ${mountPath}`);\n      return this.createNewMount(mountPath, fsType, fsName, fetchMethod, fetchInfo, versioning, merging);\n    } catch (error) {\n      consoleDotError('Mount operation failed:', error);\n      throw error;\n    }\n  }\n\n  async retrieveAndMountFromFsTable() {\n    consoleDotLog('Attempting to retrieve and mount filesystems from fsTable');\n    try {\n      // First check if we have any data at all\n      const hasData = await this.storageUtils.ensureObjectStoreExists();\n      if (!hasData) {\n        consoleDotLog('No storage data found - fresh initialization');\n        return false;\n      }\n  \n      const allMounts = await this.storageUtils.getAll();\n      consoleDotLog('Retrieved all mounts from storage:', allMounts);\n      if (!allMounts || Object.keys(allMounts).length === 0) {\n        consoleDotLog('No stored mounts found in fsTable');\n        return false;\n      }\n  \n      consoleDotLog(`Found ${Object.keys(allMounts).length} stored mounts`);\n      \n   \n      for (const mountPath in allMounts) {\n        const mountData = allMounts[mountPath];\n        if (!mountData) continue;\n\n        consoleDotLog(`Processing mount at ${mountPath} from fsTable`);\n        \n        try {\n          const lastSlashIndex = mountPath.lastIndexOf('/');\n          const path = mountPath.substring(0, lastSlashIndex);\n          const fsName = mountPath.substring(lastSlashIndex + 1);\n\n          await this.mount(\n            path,\n            mountData.fsType,\n            fsName,\n            mountData.fetchMethod,\n            {\n              fetchInfo: mountData.fetchInfo,\n              versioning: mountData.versioning,\n              merging: mountData.merging\n            }\n          );\n          \n          consoleDotLog(`Successfully mounted ${mountPath} from fsTable`);\n        } catch (mountError) {\n          consoleDotError(`Failed to mount ${mountPath} from fsTable:`, mountError);\n        }\n      }\n      \n      consoleDotLog('Finished mounting all filesystems from fsTable');\n      return true;\n        \n    } catch (error) {\n      consoleDotError('Failed to retrieve and mount:', error);\n      return false;\n    }\n  }\n\n  async initializeStoredMount(mountPath, storedMount, fetchMethod, fetchInfo, options) {\n    consoleDotLog(`Initializing stored mount at ${mountPath}`);\n    try {\n      consoleDotLog(`Creating FS instance for stored mount (type: ${storedMount.fsType})`);\n      const fsInstance = await this.createFSInstance(\n        storedMount.fsType,\n        mountPath,\n        { \n          versioning: this.getVersioningConfig(storedMount),\n          merging: this.getMergingConfig(storedMount)\n        }\n      );\n\n      consoleDotLog(`Fetching data for stored mount using method: ${storedMount.fetchMethod || fetchMethod}`);\n      await this.fetchFS(\n        storedMount.fetchMethod || fetchMethod,\n        storedMount.fsType,\n        fsInstance,\n        mountPath,\n        storedMount.fetchInfo || fetchInfo\n      );\n\n      // Update environment info and access log\n      const environment = this.getPlatformInfo();\n      const accessLog = storedMount.accessLog || [];\n      accessLog.push({\n        time: new Date().toISOString(),\n        action: 'remount',\n        environment: environment\n      });\n\n      this.mounts[mountPath] = {\n        ...storedMount,\n        fsInstance,\n        fetchMethod: storedMount.fetchMethod || fetchMethod,\n        fetchInfo: {\n          ...(storedMount.fetchInfo || fetchInfo),\n          lastFetched: new Date().toISOString()\n        },\n        versioning: this.getVersioningConfig(storedMount),\n        merging: this.getMergingConfig(storedMount),\n        environment, // Update environment info\n        modified: new Date().toISOString(),\n        accessLog\n      };      \n\n      this.initializedMounts.add(mountPath);\n      consoleDotLog(`Successfully initialized stored mount at ${mountPath}`);\n      return this.mounts[mountPath];\n    } catch (error) {\n      consoleDotError(`Failed to initialize stored mount at ${mountPath}:`, error);\n      throw error;\n    }\n  }\n\n  async createNewMount(mountPath, fsType, fsName, fetchMethod, fetchInfo, versioning = {}, merging = {}) {\n    consoleDotLog(`Creating new mount at ${mountPath}`);\n    try {\n        consoleDotLog(`Creating new FS instance (type: ${fsType})`);\n        const fsInstance = await this.createFSInstance(fsType, mountPath, { versioning, merging });\n        \n        consoleDotLog(`Fetching data for new mount using method: ${fetchMethod}`);\n        await this.fetchFS(fetchMethod, fsType, fsInstance, mountPath, fetchInfo);\n\n        // Get the VFSutils instance that was created in fetchFS\n        const vfsUtils = this.vfsUtilsInstances.get(mountPath);\n        if (!vfsUtils) {\n            throw new Error('VFSutils instance not found for mount');\n        }\n\n        consoleDotLog('Generating filesystem table');\n        const fsTable = await vfsUtils.generateFsTable();  // Use the instance from the Map\n        const fsSize = await vfsUtils.getFsTableSize(fsTable);\n        consoleDotLog(`Filesystem table generated, size: ${fsSize}`);\n\n      // Get environment information\n      const environment = this.getPlatformInfo();\n      \n      const mountData = {\n        fsInstance,\n        fsType: fsInstance instanceof MemoryFS ? 'memory' : fsType,\n        fsName,\n        fsTable,\n        fetchMethod,\n        fetchInfo: {\n          ...fetchInfo,\n          time: new Date().toISOString(),\n          size: fsSize,\n          lastFetched: new Date().toISOString()\n        },\n        versioning: this.getVersioningConfig({ versioning }),\n        merging: this.getMergingConfig({ merging }),\n        environment, // Add environment info\n        created: new Date().toISOString(),\n        modified: new Date().toISOString(),\n        accessLog: [{\n          time: new Date().toISOString(),\n          action: 'mount',\n          environment: environment\n        }]\n      };\n      \n      this.mounts[mountPath] = mountData;\n      consoleDotLog(`Persisting mount data for ${mountPath}`);\n      await this.persistMountData(mountPath, mountData);\n      \n      this.initializedMounts.add(mountPath);\n      consoleDotLog(`Successfully mounted new filesystem at ${mountPath}`);\n      return mountData;\n    } catch (error) {\n      consoleDotError(`Failed to create new mount at ${mountPath}:`, error);\n      throw error;\n    }\n  }\n\n  async getMountPaths() {\n    return Object.keys(this.mounts);\n  }\n\n  async getMountInfo(mountPath) {\n    if (!this.mounts[mountPath]) {\n      const errorMsg = `Mount not found: ${mountPath}`;\n      consoleDotError(errorMsg);\n      throw new Error(errorMsg);\n    }\n    \n    const mountData = this.mounts[mountPath];\n    return {\n      path: mountPath,\n      type: mountData.fsType,\n      name: mountData.fsName,\n      fetchMethod: mountData.fetchMethod,\n      versioning: mountData.versioning,\n      merging: mountData.merging,\n      created: mountData.created,\n      modified: mountData.modified,\n      lastFetched: mountData.fetchInfo.lastFetched,\n      size: mountData.fetchInfo.size,\n      environment: mountData.environment,\n      accessLog: mountData.accessLog\n    };\n  }\n\n  async unmount(path, fsName) {\n    const fsPath = path + '/' + fsName;\n    consoleDotLog(`Unmounting filesystem at ${fsPath}`);\n    \n    if (!this.mounts[fsPath]) {\n      const errorMsg = `Path ${fsPath} is not mounted`;\n      consoleDotError(errorMsg);\n      throw new Error(errorMsg);\n    }\n  \n    const mountData = this.mounts[fsPath];\n  \n    try {\n      // Clean up VFSutils instance if it exists\n      if (this.vfsUtilsInstances.has(fsPath)) {\n        consoleDotLog(`Terminating VFSutils instance for ${fsPath}`);\n        await this.vfsUtilsInstances.get(fsPath).terminate(mountData.fsName, mountData.fsType);\n        this.vfsUtilsInstances.delete(fsPath);\n      }\n  \n      if (this.mounts[fsPath].fsInstance) {\n        consoleDotLog(`Closing all files for mount at ${fsPath}`);\n        await this.mounts[fsPath].fsInstance.fs_fcloseall();\n        this.mounts[fsPath].fsInstance = null;\n      }\n  \n      delete this.mounts[fsPath];\n      this.initializedMounts.delete(fsPath);\n  \n      this.storageUtils.remove(fsPath);\n      consoleDotLog(`Successfully unmounted ${fsPath}`);\n      return true;\n    } catch (error) {\n      consoleDotError(`Error unmounting ${fsPath}:`, error);\n      throw error;\n    }\n  }\n\n  // Filesystem Operations\n  async fetchFS(fetchMethod, fsType, fsInstance, fsName, fetchInfo, useSW = false) {\n    consoleDotLog(`Fetching filesystem data - method: ${fetchMethod}, type: ${fsType}, name: ${fsName}`);\n    try {\n      // Check if we already have a VFSutils instance for this mount\n      if (this.vfsUtilsInstances.has(this.currentMountPath)) {\n        consoleDotLog('Terminating existing VFSutils instance for this mount');\n        await this.vfsUtilsInstances.get(this.currentMountPath).terminate();\n        this.vfsUtilsInstances.delete(this.currentMountPath);\n      }\n  \n      consoleDotLog('Creating new VFSutils instance for mount:', this.currentMountPath);\n      const vfsUtils = new VFSutils(fsType, fsInstance, fsName, fetchInfo, useSW);\n      this.vfsUtilsInstances.set(this.currentMountPath, vfsUtils);\n      \n      const fetchStrategies = {\n        git: () => vfsUtils.fetchFromGit(),\n        disk: () => vfsUtils.fetchFromDisk(),\n        googleDrive: () => vfsUtils.fetchFromGoogleDrive()\n      };\n  \n      const strategy = fetchStrategies[fetchMethod];\n      if (!strategy) {\n        const errorMsg = `Unknown fetch method: ${fetchMethod}`;\n        consoleDotError(errorMsg);\n        throw new Error(errorMsg);\n      }\n  \n      consoleDotLog(`Executing fetch strategy for ${fetchMethod}`);\n      await strategy();\n      \n      // Update last fetched time\n      if (this.mounts[this.currentMountPath]) {\n        this.mounts[this.currentMountPath].fetchInfo.lastFetched = new Date().toISOString();\n        this.mounts[this.currentMountPath].modified = new Date().toISOString();\n        await this.persistMountData(this.currentMountPath, this.mounts[this.currentMountPath]);\n      }\n      \n      consoleDotLog(`Successfully fetched data using ${fetchMethod} method`);\n    } catch (error) {\n      consoleDotError(`Fetch operation failed (method: ${fetchMethod}):`, error);\n      if (this.vfsUtilsInstances.has(this.currentMountPath)) {\n        consoleDotLog('Cleaning up VFSutils after fetch failure');\n        await this.vfsUtilsInstances.get(this.currentMountPath).terminate(fsName, fsType);\n        this.vfsUtilsInstances.delete(this.currentMountPath);\n      }\n      throw error;\n    }\n  }\n\n  async resolveFS(path) {\n    consoleDotLog(`Resolving filesystem for path: ${path}`);\n    try {\n      for (const mountPath in this.mounts) {\n        if (path.startsWith(mountPath)) {\n          consoleDotLog(`Found matching mount at `, mountPath);\n          await this.ensureFSInitialized(mountPath);\n          const relativePath = path.slice(mountPath.length) || \"/\";\n          consoleDotLog(`Resolved path: ${path} to mount: ${mountPath}, relative path: ${relativePath}, this.mounts[mountPath] : `, this.mounts[mountPath]);\n          consoleDotLog('resolveFs returned value: ', \n            {            \n            fs: this.mounts[mountPath],\n            relativePath: relativePath,\n            versioning: this.mounts[mountPath].versioning || config.versioning,\n            merging: this.mounts[mountPath].merging || config.merging\n          })\n\n          return {\n            fs: this.mounts[mountPath],\n            relativePath: relativePath,\n            versioning: this.mounts[mountPath].versioning || config.versioning,\n            merging: this.mounts[mountPath].merging || config.merging\n          };\n        }\n      }\n      const errorMsg = `No filesystem mounted for path: ${path}`;\n      consoleDotError(errorMsg);\n      throw new Error(errorMsg);\n    } catch (error) {\n      consoleDotError(`Failed to resolve filesystem for path ${path}:`, error);\n      throw error;\n    }\n  }\n\n  // Filesystem Table Operations\n  async writeToFsTable(path, type = \"file\", size = 0) {\n    consoleDotLog(`Writing to fsTable - path: ${path}, type: ${type}, size: ${size}`);\n    await this.validateVFSutils();\n    \n    try {\n      const vfsUtils = this.vfsUtilsInstances.get(this.currentMountPath);\n      consoleDotLog(`Updating fsTable with create operation for ${path}`);\n      const updateResult = await vfsUtils.updateFsTable(\"create\", path, type, size);\n      consoleDotLog(`Updating mount fsTable with new data`);\n      await this.updateMountFsTable(updateResult.fsTable);\n      consoleDotLog(`Successfully updated fsTable for ${path}`);\n      return updateResult.fsTable;\n    } catch (error) {\n      consoleDotError('Failed to write to fsTable:', error);\n      throw error;\n    }\n  }\n  \n  async removeFromFsTable(path) {\n    consoleDotLog(`Removing from fsTable - path: ${path}`);\n    await this.validateVFSutils();\n    \n    try {\n      const vfsUtils = this.vfsUtilsInstances.get(this.currentMountPath);\n      consoleDotLog(`Updating fsTable with remove operation for ${path}`);\n      const updateResult = await vfsUtils.updateFsTable(\"remove\", path);\n      consoleDotLog(`Updating mount fsTable with removal data`);\n      await this.updateMountFsTable(updateResult.fsTable);\n      consoleDotLog(`Successfully removed ${path} from fsTable`);\n      return updateResult.fsTable;\n    } catch (error) {\n      consoleDotError('Failed to remove from fsTable:', error);\n      throw error;\n    }\n  }\n\n  async updateMountFsTable(fsTable) {\n    consoleDotLog(`Updating mount fsTable for current mount path`);\n    if (!this.currentMountPath) {\n      const errorMsg = 'No active mount path available';\n      consoleDotError(errorMsg);\n      throw new Error(errorMsg);\n    }\n\n    consoleDotLog(`Loading mount data for ${this.currentMountPath}`);\n    const mountData = await this.storageUtils.get(this.currentMountPath);\n    if (!mountData) {\n      const errorMsg = `Mount data not found for path: ${this.currentMountPath}`;\n      consoleDotError(errorMsg);\n      throw new Error(errorMsg);\n    }\n\n    consoleDotLog(`Updating fsTable in mount data`);\n    mountData.fsTable = fsTable;\n    consoleDotLog(`Storing updated mount data for ${this.currentMountPath}`);\n    await this.storageUtils.store(this.currentMountPath, mountData);\n    consoleDotLog(`Successfully updated mount fsTable`);\n  }\n\n  // Validation Utilities\n  async validateVFSutils() {\n    consoleDotLog('Validating VFSutils instance');\n    if (!this.currentMountPath || !this.vfsUtilsInstances.has(this.currentMountPath)) {\n      const errorMsg = \"VFSutils not initialized for current mount\";\n      consoleDotError(errorMsg);\n      throw new Error(errorMsg);\n    }\n    consoleDotLog('VFSutils validation passed');\n  }\n \n  //----------------------\n  // Versioning Operations\n  //----------------------\n\n \n  async versioner(message) {\n    consoleDotLog(`Committing version with message: ${message}`);\n    await this.validateVFSutils();\n    \n    try {\n      const vfsUtils = this.vfsUtilsInstances.get(this.currentMountPath);\n      const commitResult = await vfsUtils.commitStagedChanges(message);\n      consoleDotLog(`Version committed successfully`);\n      return commitResult;\n    } catch (error) {\n      consoleDotError('Failed to commit version:', error);\n      throw error;\n    }\n  }\n  \n  //--------------------\n  // Merging Operations\n  //--------------------\n\n  \n  async merger(onConflictStrategy) {\n    consoleDotLog('Starting merge operation');\n    await this.validateVFSutils();\n  \n    try {\n      const vfsUtils = this.vfsUtilsInstances.get(this.currentMountPath);\n      const mergeResult = await vfsUtils.autoSyncFlow(onConflictStrategy);\n      consoleDotLog('Merge operation completed successfully:', mergeResult);\n      return mergeResult;\n    } catch (error) {\n      consoleDotError('Merge operation failed:', error);\n      throw error;\n    }\n  }\n\n  \n  //-------------------\n  // Some info setters for vfsUtils\n  //-------------------\n\n  async setMergingStrategy(mergingStrategy) {\n    consoleDotLog('Setting merging strategy');\n    let mountData = this.mounts[this.currentMountPath];\n    mountData = {...mountData, merging: mergingStrategy};\n    await this.persistMountData(this.currentMountPath, mountData);\n    consoleDotLog('Merging strategy set successfully:', mergingStrategy);\n    return true;\n  }\n\n  async setVersioingStrategy(versioningStrategy) {\n    consoleDotLog('Setting versioning strategy');\n    let mountData = this.mounts[this.currentMountPath];\n    mountData = {...mountData, versioning: versioningStrategy};\n    await this.persistMountData(this.currentMountPath, mountData);\n    consoleDotLog('Versioning strategy set successfully:', versioningStrategy);\n    return true;\n  }\n\n  async setUserConfigs(args) {\n    await this.validateVFSutils();\n    consoleDotLog('Setting user configurations:', args);\n    const vfsUtils = this.vfsUtilsInstances.get(this.currentMountPath);\n    await vfsUtils.updateFetchInfo(args);\n    let mountData = this.mounts[this.currentMountPath];\n    mountData = { ...mountData, fetchInfo: { ...mountData.fetchInfo, ...args } };\n    this.persistMountData(this.currentMountPath, mountData);\n    return args;\n  }\n}","import { config } from './../../configES6.js';\nimport { Logger } from './../LoggerES6.js';\n\nconst logger = new Logger(config.logging.kfs);\n\nfunction consoleDotLog(...params) {\n  logger.consoleDotLog('[Versioning]', ...params);\n}\n\nfunction consoleDotError(...params) {\n  logger.consoleDotError('[Versioning]', ...params);\n}\n\nexport class VersioningManager {\n  constructor(vfs) {\n    this.vfs = vfs;\n    this.clockIntervalID = null;\n    this.operationQueueCount = 0;\n    this.config = this._getDefaultVersioningConfig();\n  }\n\n  _getDefaultVersioningConfig() {\n    const versioning = config.versioning || {};\n    return {\n      strategy: versioning.strategy,\n      interval: versioning.interval,\n      number: versioning.number,\n    };\n  }\n\n  async _getVersioningConfig(options = {}) {\n    const defaultConfig = this._getDefaultVersioningConfig();\n    const versioning = options.versioning || {};\n    return {\n      strategy: versioning.strategy || defaultConfig.strategy,\n      interval: versioning.interval || defaultConfig.interval,\n      number: versioning.number || defaultConfig.number,\n    };\n  }\n\n  async setup(options = {}) {\n    this.config = await this._getVersioningConfig(options);\n    consoleDotLog('Versioning configuration:', this.config);\n\n    if (this.config.strategy === 'clock') {\n      this._startClockVersioning();\n    } else {\n      this.clearClock();\n    }\n  }\n\n  clearClock() {\n    if (this.clockIntervalID) {\n      clearInterval(this.clockIntervalID);\n      this.clockIntervalID = null;\n    }\n  }\n\n  _startClockVersioning() {\n    this.clearClock();\n    const intervalMs = (this.config.interval || 10) * 1000;\n    consoleDotLog('Starting clock-based versioning with interval:', intervalMs, 'ms');\n\n    this.clockIntervalID = setInterval(async () => {\n      consoleDotLog('Clock-based auto commit triggered');\n      try {\n        await this.vfs.versioner('Clock-based auto commit');\n      } catch (error) {\n        consoleDotError('Error in clock-based versioning:', error);\n      }\n    }, intervalMs);\n  }\n\n  async maybeTriggerVersioning(overrideConfig = null) {\n    const strategyConfig = overrideConfig || this.config;\n    if (strategyConfig.strategy === 'immediate') return;\n\n    if (strategyConfig.strategy === 'batch') {\n      this.operationQueueCount++;\n      const batchSize = strategyConfig.number || 5;\n      consoleDotLog(`Batch operation count: ${this.operationQueueCount}/${batchSize}`);\n\n      if (this.operationQueueCount >= batchSize) {\n        this.operationQueueCount = 0;\n        await this.vfs.versioner(`Batch commit after ${batchSize} operations`);\n      }\n    }\n  }\n\n  async getConfig() {\n    return this.config;\n  }\n}\n","import { config } from './../../configES6.js';\nimport { Logger } from './../LoggerES6.js';\n\nconst logger = new Logger(config.logging.kfs);\n\nfunction consoleDotLog(...params) {\n  logger.consoleDotLog('[Merging]', ...params);\n}\n\nfunction consoleDotError(...params) {\n  logger.consoleDotError('[Merging]', ...params);\n}\n\nexport class MergingManager {\n    constructor(vfs) {\n      this.vfs = vfs;\n      this.clockIntervalID = null;\n      this.config = this._getDefaultMergingConfig();\n    }\n  \n    _getDefaultMergingConfig() {\n      return {\n        strategy: config.merging?.strategy || null,\n        interval: config.merging?.interval || 10,\n        number: config.merging?.number || 5\n      };\n    }\n  \n    async setup(options = {}) {\n        this.config = {\n          ...this._getDefaultMergingConfig(),\n          ...(options.merging || {})\n        };\n      \n        if (this.config.strategy === 'clock') {\n          await this._startClockMerging(); // Now async\n        } else {\n          this.clearClock();\n        }\n      }\n      \n      async _startClockMerging() {\n        this.clearClock();\n        const intervalMs = this.config.interval * 1000;\n        this.clockIntervalID = setInterval(async () => {\n          try {\n            await this.vfs.merger();\n          } catch (error) {\n            console.error('Clock-based merge failed:', error);\n          }\n        }, intervalMs);\n      }\n\n    clearClock() {\n      if (this.clockIntervalID) {\n        clearInterval(this.clockIntervalID);\n        this.clockIntervalID = null;\n      }\n    }\n\n    async getConfig() {\n        return this.config;\n      }\n  }","import { VFS } from \"./vfs.js\";\nimport { Logger } from \"./libs/LoggerES6.js\";\nimport { getConfig } from './configES6.js';\nimport { VersioningManager } from './libs/kfsUtils/versioningManager.js';\nimport { MergingManager } from './libs/kfsUtils/mergingManager.js';\n\nconst config = await getConfig();\nconst logger = new Logger(config.logging.kfs);\n\nfunction consoleDotLog(...params) {\n  logger.consoleDotLog('[KFS]', ...params);\n}\n\nfunction consoleDotError(...params) {\n  logger.consoleDotError('[KFS]', ...params);\n}\n\nexport class KFS {\n  constructor() {\n    this.vfs = new VFS();\n    this.fsInstance = null;\n    this.versioningManager = new VersioningManager(this.vfs);\n    this.mergingManager = new MergingManager(this.vfs);    \n    this.commitCount = 0;\n    this.mountPaths = null;\n    this.mergingConfig = null;\n    (async () => {\n      try {\n        await this.init();\n      } catch (error) {\n        consoleDotError('Initing Failed for KFS: ', error);\n      }\n    })();\n    consoleDotLog('KFS instance created');\n  }\n  \n  async init() {\n    if (!this.initialized) {\n      this.mountPaths = await this.vfs.getMountPaths();\n      this.initialized = true;\n    }\n    consoleDotLog('mountpaths: ', this.mountPaths)\n    return this;\n  }\n\n  // -------------------------------\n  // Versioning Configuration\n  // -------------------------------\n  \n  _setupVersioningAndMerging(options) {\n    this.versioningManager.setup(options);\n    this.mergingManager.setup(options);\n  }\n  \n  _clearClocks() {\n    this.versioningManager.clearClock();\n    this.mergingManager.clearClock();\n  }\n  \n  async _handleCommit(message) {\n    const versioningConfig = await this.versioningManager.getConfig();\n    this.mergingConfig = await this.mergingManager.getConfig();\n    const strategyMap = { remote: 'theirs', local: 'ours', combine: 'combine' };\n    const userStrategy = this.mergingConfig?.onConflictStrategy || 'remote';\n    const onConflictStrategy = strategyMap[userStrategy] || 'remote';\n\n    await this.vfs.versioner(message);\n    this.commitCount++;\n    \n    if (this.mergingConfig.strategy === 'immediate') {\n      await this.vfs.merger(onConflictStrategy);\n    }\n  }\n  \n  async merge() {\n    try {\n      const strategyMap = { remote: 'theirs', local: 'ours', combine: 'combine' };\n      const userStrategy = this.mergingConfig?.onConflictStrategy || 'remote';\n      const onConflictStrategy = strategyMap[userStrategy] || 'remote';\n\n      consoleDotLog('Merging...');\n      await this.vfs.merger(onConflictStrategy);\n      consoleDotLog('Merge completed successfully.');\n    } catch(error) {\n      consoleDotError('Merge failed:', error);\n      throw new Error(`Failed to merge: ${error.message}`);\n    }\n  }\n  \n  // -------------------------------\n  // Filesystem Operations\n  // -------------------------------\n\n  async mount(path, fsType, fsName, fetchMethod, options = {}) {\n    try {\n      this._setupVersioningAndMerging(options);\n      \n      path = this._normalizePath(path);\n      const versioningConfig = await this.versioningManager.getConfig();\n      this.mergingConfig = await this.mergingManager.getConfig();\n      \n      const mountData = await this.vfs.mount(path, fsType, fsName, fetchMethod, {\n        ...options,\n        versioning: versioningConfig,\n        merging: this.mergingConfig\n      });\n\n      this.fsInstance = mountData.fsInstance;\n      const root = await this.read(`${path}/${fsName}`);\n      this.mountPaths = await this.vfs.getMountPaths();\n      consoleDotLog('Mount successful, root:', root);\n      return mountData;\n    } catch (error) {\n      consoleDotError(`Failed to mount filesystem at ${path}:`, error);\n      throw new Error(`Failed to mount filesystem: ${error.message}`);\n    }\n  }\n\n  async unmount(path, fsName) {\n    try {\n      path = this._normalizePath(path);\n      await this.vfs.unmount(path, fsName);\n      this.fsInstance = null;\n      this._clearClocks();\n      this.commitCount = 0;\n      return { success: true };\n    } catch (error) {\n      consoleDotError(`Failed to unmount filesystem at ${path}:`, error);\n      throw new Error(`Failed to unmount filesystem: ${error.message}`);\n    }\n  }\n\n\n  async setMergingStrategy(mergingStrategy) {\n    await this.vfs.setMergingStrategy(mergingStrategy);\n    consoleDotLog('Merging strategy set to:', mergingStrategy);\n  }\n\n  async setVersioingStrategy(versioningStrategy) {\n    await this.vfs.setVersioingStrategy(versioningStrategy);\n    consoleDotLog('Versioning strategy set to:', versioningStrategy);\n  }\n\n  /**\n   * Sets user configurations for the KFS instance.\n    * @param {string} [args.name] - The name of the user.\n    * @param {string} [args.email] - The email of the user.\n    * @param {string} [args.username] - The username of the user.\n    * @param {string} [args.password] - The password of the user.\n    * @throws {Error} - Throws an error if the arguments are invalid or if the operation fails.\n   */\n  async setUserConfigs(args) {\n    if (!args || typeof args !== 'object') {\n      throw new Error('Invalid arguments: must be an object');\n    }\n    const allowedFields = ['password', 'username', 'email', 'name'];\n    const invalidFields = Object.keys(args).filter(\n      field => !allowedFields.includes(field)\n    );\n  \n    if (invalidFields.length > 0) {\n      throw new Error(\n        `Invalid field(s) provided: ${invalidFields.join(', ')}. ` +\n        `Allowed fields are: ${allowedFields.join(', ')}`\n      );\n    }\n    \n    args && this.vfs.setUserConfigs(args);\n    return args;\n  }\n\n  async create(path, type = 'file', content = '', mode = 'w') {\n    try {\n      if (!['file', 'dir'].includes(type)) {\n        throw new Error(`Invalid type: ${type}. Must be 'file' or 'dir'`);\n      }\n      if (!['a', 'w'].includes(mode)) {\n        throw new Error(`Invalid mode: ${mode}. Must be 'a' (append) or 'w' (write)`);\n      }\n  \n      path = this._normalizePath(path);\n\n      if (this.mountPaths.includes(path)) {\n        throw new Error(`Cannot write directly to mount path (${path}). Use mount() instead.`);\n      }\n\n\n      const { fs, relativePath, versioning } = await this.vfs.resolveFS(path);\n  \n      if (type === 'file') {\n        await this._ensurePathExists(fs, relativePath);\n        \n        let finalContent = content;\n        let operationMessage = `Created file at ${path}`;\n        \n        if (mode === 'a') {\n          try {\n            // Try to read existing content\n            const fd = await fs.fsInstance.fs_fopen(relativePath, 'r');\n            const existingContent = await fs.fsInstance.fs_fread(fd, 1024*1024); // Read up to 1MB\n            await fs.fsInstance.fs_fclose(fd);\n            \n            finalContent = existingContent + content;\n            operationMessage = `Appended to file at ${path}`;\n          } catch (readError) {\n            // File doesn't exist yet, proceed with normal creation\n            operationMessage = `Created file at ${path}`;\n          }\n        }\n  \n        const fd = await fs.fsInstance.fs_fopen(relativePath, 'w'); // Always use 'w' here since we've handled append logic\n        const writeResult = await fs.fsInstance.fs_fwrite(fd, finalContent);\n        if (writeResult === -1) {\n          throw new Error('Failed to write to file');\n        }\n        \n        await fs.fsInstance.fs_fclose(fd);\n  \n        await this.vfs.writeToFsTable(relativePath, type, finalContent.length);\n  \n        if (versioning?.strategy === 'immediate') {\n          await this._handleCommit(operationMessage);\n        } else {\n          await this.versioningManager.maybeTriggerVersioning(versioning);\n        }\n      } else if (type === 'dir') {\n        if (mode === 'a') {\n          // For directories, 'a' mode means don't throw if already exists\n          try {\n            await fs.fsInstance.fs_mkdir(relativePath);\n            await this.vfs.writeToFsTable(relativePath, type, 0);\n            \n            if (versioning?.strategy === 'immediate') {\n              await this._handleCommit(`Created directory at ${path}`);\n            }\n          } catch (error) {\n            if (!error.message.includes('exists')) throw error;\n            // Directory already exists - no action needed for append mode\n          }\n        } else { // mode === 'w'\n          // For 'w' mode, try to remove existing first (like truncate for files)\n          try {\n            const stats = await fs.fsInstance.fs_stat(relativePath);\n            if (await stats.isDirectory()) {\n              await fs.fsInstance.fs_rmdir(relativePath);\n            } else {\n              await fs.fsInstance.fs_remove(relativePath);\n            }\n          } catch (error) {\n            // Doesn't exist - that's fine\n          }\n          \n          await fs.fsInstance.fs_mkdir(relativePath);\n          await this.vfs.writeToFsTable(relativePath, type, 0);\n          \n          if (versioning?.strategy === 'immediate') {\n            await this._handleCommit(`Created directory at ${path}`);\n          }\n        }\n      }\n  \n      return { success: true };\n    } catch (error) {\n      consoleDotError(`Failed to create ${type} at ${path}:`, error);\n      throw new Error(`Failed to create: ${error.message}`);\n    }\n  }\n\n  async remove(path) {\n    try {\n      path = this._normalizePath(path);\n\n      if (this.mountPaths.includes(path)) {\n        throw new Error(`Cannot remove path (${path}) directly. Use unmount() instead.`);\n      }\n      const { fs, relativePath, versioning } = await this.vfs.resolveFS(path);\n\n      const stats = await fs.fsInstance.fs_stat(relativePath);\n      if (!stats) throw new Error('ENOENT: no such file or directory');\n\n      if (await stats.isDirectory()) {\n        await fs.fsInstance.fs_rmdir(relativePath);\n      } else {\n        await fs.fsInstance.fs_remove(relativePath);\n      }\n\n      await this.vfs.removeFromFsTable(relativePath);\n\n      if (versioning?.strategy === 'immediate') {\n        await this._handleCommit(`Removed ${path}`);\n      } else {\n        await this.versioningManager.maybeTriggerVersioning(versioning);\n      }\n\n      return { success: true };\n    } catch (error) {\n      consoleDotError(`Failed to remove ${path}:`, error);\n      throw new Error(`Failed to remove: ${error.message}`);\n    }\n  }\n\n  async read(path) {\n    try {\n      path = this._normalizePath(path);\n      const { fs, relativePath } = await this.vfs.resolveFS(path);\n      this.fsInstance = fs.fsInstance;\n\n      const stats = await this.fsInstance.fs_stat(relativePath);\n      if (!stats) throw new Error('ENOENT: no such file or directory');\n\n      if (await stats.isDirectory()) {\n        const result = await this.fsInstance.fs_readdir(relativePath);\n        consoleDotLog('result', result)\n        return result;\n      } else {\n        const fd = await this.fsInstance.fs_fopen(relativePath, 'r');\n        const data = await this.fsInstance.fs_fread(fd, 1024*1024);\n        await this.fsInstance.fs_fclose(fd);\n        return data;\n      }\n    } catch (error) {\n      throw new Error(`Failed to read file: ${error.message}`);\n    }\n  }\n\n  // -------------------------------\n  // Utility Methods\n  // -------------------------------\n  async _ensurePathExists(fs, path) {\n    const parts = path.split('/').filter(p => p !== '');\n    \n    const dirParts = parts.slice(0, -1);\n    let currentPath = '';\n    \n    for (const part of dirParts) {\n        currentPath = currentPath ? `${currentPath}/${part}` : `/${part}`;\n        try {\n            await fs.fsInstance.fs_mkdir(currentPath);\n            await this.vfs.writeToFsTable(currentPath, 'dir');\n        } catch (error) {\n            if (!error.message.includes('exists')) consoleDotError(error);\n        }\n    }\n  }\n\n  _normalizePath(path) {\n    if (typeof path !== 'string') throw new Error('Path must be a string');\n    return path.startsWith('/') ? path : `/${path}`;\n  }\n}\n\nexport { serviceWorker } from './libs/sw-register.js';\nexport { setConfig } from './configES6.js';"],"names":["e","t","n","o","s","i","r","c","MagicPortal","logger","Logger","config","consoleDotLog","parameters","consoleDotError","WorkerPool","workerClass","mountPath","useSW","worker","GitWorker","portal","thread","_","reject","swSupport","entry","error","path","workerPool","MemoryFS","fsName","options","filename","mode","parentDir","dirExists","fd","length","file","data","chunk","content","offset","whence","normalizedPath","exists","noteType","noteData","metadata","stats","oldPath","newPath","newParentDir","parentExists","eof","IDBFs","LightningFS","GitAuth","workerThread","username","password","name","email","VFSutils","fsType","fsInstance","fetchInfo","url","dir","cloneResult","fileId","fileList","root","pathParts","p","current","part","index","isLast","existing","expectedType","action","type","size","parentInode","isDir","fsTable","message","_url","ref","localHead","remoteResult","remoteHead","localCommits","remoteCommits","commonCommit","status","err","remoteSet","commit","depth","commits","result","onConflictStrategy","commonAncestor","_onConflictStrategy","pullResult","mergeResult","newLocalHead","resetError","pushNotesResult","newStatus","pushResult","args","newFetchInfo","row","StorageUtils","dbName","resolve","request","db","event","key","item","getRequest","getAllKeysRequest","keys","value","dataStr","indexedSuccess","localSuccess","success","transaction","checkIndexedDBSupport","deleteRequest","VFS","storageName","userAgent","browser","versioning","merging","storedMount","mountData","dataToStore","errorMsg","fsPath","fetchMethod","allMounts","lastSlashIndex","mountError","environment","accessLog","vfsUtils","fsSize","strategy","relativePath","updateResult","commitResult","mergingStrategy","versioningStrategy","params","VersioningManager","vfs","defaultConfig","intervalMs","overrideConfig","strategyConfig","batchSize","MergingManager","getConfig","KFS","strategyMap","userStrategy","versioningConfig","allowedFields","invalidFields","field","fs","finalContent","operationMessage","existingContent","dirParts","currentPath"],"mappings":"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"}